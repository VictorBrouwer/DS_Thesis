[
  {
    "algorithm": "Modified version of: Modified version of: Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n    unvisited = state.unvisited[:]\n\n    # Sort unvisited nodes by a combination of prize-to-penalty ratio and distance to tour\n    def sorting_key(node):\n        closest_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                closest_dist = min(closest_dist, dist)\n        else:\n            closest_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n        return DATA.prizes[node] / (DATA.penalties[node] + 0.0001) - 0.01 * closest_dist #Adding small constant to penalty to avoid division by zero, scaling distance to prioritize high prize-to-penalty\n\n    unvisited.sort(key=sorting_key, reverse=True)\n\n    for node in unvisited:\n        state.opt_insert(node)\n    \n    # Ensure feasibility\n    while not state.is_feasible():\n        # Prioritize removing nodes with low prize and high cost of insertion\n        worst_node = None\n        worst_metric = float('inf')\n        for node in state.tour:\n            prize = DATA.prizes[node]\n            \n            # Estimate insertion cost (more accurate)\n            idx = state.tour.index(node)\n            if len(state.tour) > 1:\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost = np.linalg.norm(DATA.locations[node] - DATA.locations[prev_node]) + \\\n                       np.linalg.norm(DATA.locations[node] - DATA.locations[next_node]) - \\\n                       np.linalg.norm(DATA.locations[prev_node] - DATA.locations[next_node])\n            else:\n                cost = 2 * np.linalg.norm(DATA.locations[node] - DATA.depot)\n            \n            # Metric: low prize, high insertion cost\n            metric = (cost + 0.0001) / (prize + 0.0001) # adding small constant to avoid division by zero\n\n            if metric < worst_metric:\n                worst_metric = metric\n                worst_node = node\n                \n        if worst_node is not None:\n            state.remove(worst_node)\n            state.unvisited.append(worst_node)\n            \n    # Adaptive node swapping based on potential gain\n    num_swaps = min(len(state.tour), len(state.unvisited), 5) # Limit swaps for speed\n    for _ in range(num_swaps):\n        best_gain = 0\n        best_swap = None\n\n        for i in range(len(state.tour)):\n            for j in range(len(state.unvisited)):\n                node_in = state.unvisited[j]\n                node_out = state.tour[i]\n\n                # Evaluate the potential gain from swapping\n                prize_diff = DATA.prizes[node_in] - DATA.prizes[node_out]\n                penalty_diff = DATA.penalties[node_out] - DATA.penalties[node_in]\n\n                # More accurate cost estimation\n                idx = state.tour.index(node_out)\n                if len(state.tour) > 1:\n                    prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                    next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n\n                    cost_diff = (np.linalg.norm(DATA.locations[node_in] - DATA.locations[prev_node]) +\n                                 np.linalg.norm(DATA.locations[node_in] - DATA.locations[next_node]) -\n                                 np.linalg.norm(DATA.locations[node_out] - DATA.locations[prev_node]) -\n                                 np.linalg.norm(DATA.locations[node_out] - DATA.locations[next_node]))\n                else:\n                    cost_diff = (2 * np.linalg.norm(DATA.locations[node_in] - DATA.depot) -\n                                 2 * np.linalg.norm(DATA.locations[node_out] - DATA.depot))\n\n                gain = prize_diff - penalty_diff - cost_diff\n\n                if gain > best_gain:\n                    best_gain = gain\n                    best_swap = (i, j)\n\n        if best_swap is not None and best_gain > 0:\n            i, j = best_swap\n            node_in = state.unvisited[j]\n            node_out = state.tour[i]\n            \n            state.remove(node_out)\n            state.unvisited.append(node_out)\n            state.insert(node_in, i)  # insert at the same location that the node was removed from\n            state.unvisited.remove(node_in)\n        else:\n            break\n\n    return state",
    "objective": 11.793883517001941,
    "gap": -20.436714250366457,
    "runtime": 60.045737981796265,
    "timestamp": "2025-06-13 14:31:33",
    "feasible": true,
    "instance1_objective": 5.9850375363823956,
    "instance2_objective": 5.808845980619546,
    "instance1_gap": -25.5168829827322,
    "instance2_gap": -15.356545518000717,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.6335959601441985,
    "strategy": "m1",
    "generation": 3
  },
  {
    "algorithm": "Modified version of: Modified version of: Modified version of: Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n    unvisited = state.unvisited[:]\n\n    # Sort unvisited nodes by a combination of prize-to-penalty ratio and distance to tour\n    def sorting_key(node):\n        closest_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                closest_dist = min(closest_dist, dist)\n        else:\n            closest_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n        return DATA.prizes[node] / (DATA.penalties[node] + 0.0001) - 0.005 * closest_dist #Slightly reduce scaling distance\n\n    unvisited.sort(key=sorting_key, reverse=True)\n\n    # Insert nodes using best insertion *after* sorting\n    for node in unvisited:\n        state.opt_insert(node)\n    \n    # Ensure feasibility more efficiently by targeting specific removals\n    while not state.is_feasible():\n        # Prioritize removing nodes with lowest (prize - insertion cost)\n        worst_node = None\n        worst_metric = float('inf')\n        for node in state.tour:\n            prize = DATA.prizes[node]\n            \n            # Estimate insertion cost (more accurate)\n            idx = state.tour.index(node)\n            if len(state.tour) > 1:\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost = np.linalg.norm(DATA.locations[node] - DATA.locations[prev_node]) + \\\n                       np.linalg.norm(DATA.locations[node] - DATA.locations[next_node]) - \\\n                       np.linalg.norm(DATA.locations[prev_node] - DATA.locations[next_node])\n            else:\n                cost = 2 * np.linalg.norm(DATA.locations[node] - DATA.depot)\n            \n            metric = (cost + DATA.penalties[node]) / (prize + 0.0001)\n\n            if metric < worst_metric:\n                worst_metric = metric\n                worst_node = node\n                \n        if worst_node is not None:\n            state.remove(worst_node)\n            state.unvisited.append(worst_node)\n        else:\n            #If no node can be removed without dropping feasibility, break.  This is rare.\n            break\n    \n    # Adaptive node swapping based on potential gain, focused on improving infeasibility\n    num_swaps = min(len(state.tour), len(state.unvisited), 5)\n    for _ in range(num_swaps):\n        best_gain = 0\n        best_swap = None\n\n        for i in range(len(state.tour)):\n            for j in range(len(state.unvisited)):\n                node_in = state.unvisited[j]\n                node_out = state.tour[i]\n\n                # Evaluate the potential gain from swapping\n                prize_diff = DATA.prizes[node_in] - DATA.prizes[node_out]\n                penalty_diff = DATA.penalties[node_out] - DATA.penalties[node_in]\n\n                idx = state.tour.index(node_out)\n                if len(state.tour) > 1:\n                    prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                    next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n\n                    cost_diff = (np.linalg.norm(DATA.locations[node_in] - DATA.locations[prev_node]) +\n                                 np.linalg.norm(DATA.locations[node_in] - DATA.locations[next_node]) -\n                                 np.linalg.norm(DATA.locations[node_out] - DATA.locations[prev_node]) -\n                                 np.linalg.norm(DATA.locations[node_out] - DATA.locations[next_node]))\n                else:\n                    cost_diff = (2 * np.linalg.norm(DATA.locations[node_in] - DATA.depot) -\n                                 2 * np.linalg.norm(DATA.locations[node_out] - DATA.depot))\n\n                gain = prize_diff - penalty_diff - cost_diff\n\n                if gain > best_gain:\n                    best_gain = gain\n                    best_swap = (i, j)\n\n        if best_swap is not None and best_gain > 0:\n            i, j = best_swap\n            node_in = state.unvisited[j]\n            node_out = state.tour[i]\n            \n            state.remove(node_out)\n            state.unvisited.append(node_out)\n            state.insert(node_in, i)  # insert at the same location that the node was removed from\n            state.unvisited.remove(node_in)\n        else:\n            break\n\n    return state",
    "objective": 11.793883517001941,
    "gap": -20.436714250366457,
    "runtime": 60.0254967212677,
    "timestamp": "2025-06-13 14:34:59",
    "feasible": true,
    "instance1_objective": 5.9850375363823956,
    "instance2_objective": 5.808845980619546,
    "instance1_gap": -25.5168829827322,
    "instance2_gap": -15.356545518000717,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.6335959601441985,
    "strategy": "m1",
    "generation": 4
  },
  {
    "algorithm": "Modified version of: Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n    unvisited = state.unvisited[:]\n\n    # Sort unvisited nodes by prize-to-penalty ratio (high to low)\n    unvisited.sort(key=lambda node: DATA.prizes[node] / DATA.penalties[node], reverse=True)\n\n    for node in unvisited:\n        state.opt_insert(node)\n\n    # Ensure feasibility\n    while not state.is_feasible():\n        # Remove node with the lowest (prize - penalty) / cost ratio\n        worst_node = None\n        worst_ratio = float('inf')\n        for node in state.tour:\n            prize = DATA.prizes[node]\n            penalty = DATA.penalties[node]\n            idx = state.tour.index(node)\n            if len(state.tour) > 1:\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost = np.linalg.norm(DATA.locations[node] - DATA.locations[prev_node]) + \\\n                       np.linalg.norm(DATA.locations[node] - DATA.locations[next_node])\n            else:\n                cost = 2 * np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n            ratio = (prize - penalty) / cost if cost > 0 else float('inf')\n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        if worst_node is not None:\n            state.remove(worst_node)\n            state.unvisited.append(worst_node)\n            \n    # Try to improve by swapping nodes\n    for i in range(len(state.tour)):\n        for j in range(len(state.unvisited)):\n            node_in = state.unvisited[j]\n            node_out = state.tour[i]\n            \n            # Evaluate the potential gain from swapping\n            prize_diff = DATA.prizes[node_in] - DATA.prizes[node_out]\n            penalty_diff = DATA.penalties[node_out] - DATA.penalties[node_in]\n            \n            # Rough cost estimation (can be made more precise)\n            if len(state.tour) > 1:\n                idx = state.tour.index(node_out)\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost_diff = (np.linalg.norm(DATA.locations[node_in] - DATA.locations[prev_node]) + \\\n                             np.linalg.norm(DATA.locations[node_in] - DATA.locations[next_node]) - \\\n                             np.linalg.norm(DATA.locations[node_out] - DATA.locations[prev_node]) - \\\n                             np.linalg.norm(DATA.locations[node_out] - DATA.locations[next_node]))\n            else:\n                cost_diff = (2 * np.linalg.norm(DATA.locations[node_in] - DATA.depot) - \\\n                            2 * np.linalg.norm(DATA.locations[node_out] - DATA.depot))\n            \n            gain = prize_diff - penalty_diff - cost_diff\n            \n            if gain > 0:\n                state.remove(node_out)\n                state.unvisited.append(node_out)\n                state.opt_insert(node_in)\n                state.unvisited.remove(node_in)\n                break # Only swap one node per iteration to avoid instability\n\n    return state",
    "objective": 11.819084979153438,
    "gap": -20.279899573513923,
    "runtime": 60.02359390258789,
    "timestamp": "2025-06-13 14:23:54",
    "feasible": true,
    "instance1_objective": 6.010238998533892,
    "instance2_objective": 5.808845980619546,
    "instance1_gap": -25.20325362902713,
    "instance2_gap": -15.356545518000717,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.6335959601441985,
    "strategy": "m1",
    "generation": 1
  },
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n    unvisited = state.unvisited[:]\n\n    # Sort unvisited nodes by a combination of prize-to-penalty and proximity\n    def sorting_key(node):\n        min_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                min_dist = min(min_dist, dist)\n        else:\n            min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        return DATA.prizes[node] / DATA.penalties[node] - (min_dist / 1000)  # Scale proximity\n    \n    unvisited.sort(key=sorting_key, reverse=True)\n\n\n    for node in unvisited:\n        state.opt_insert(node)\n\n    # Ensure feasibility\n    while not state.is_feasible():\n        # Remove node with the lowest (prize - penalty) / cost ratio\n        worst_node = None\n        worst_ratio = float('inf')\n        for node in state.tour:\n            prize = DATA.prizes[node]\n            penalty = DATA.penalties[node]\n            idx = state.tour.index(node)\n            if len(state.tour) > 1:\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost = np.linalg.norm(DATA.locations[node] - DATA.locations[prev_node]) + \\\n                       np.linalg.norm(DATA.locations[node] - DATA.locations[next_node])\n            else:\n                cost = 2 * np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n            ratio = (prize - penalty) / cost if cost > 0 else float('inf')\n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        if worst_node is not None:\n            state.remove(worst_node)\n            state.unvisited.append(worst_node)\n\n    # Try to improve by swapping nodes (less aggressive)\n    num_swaps = min(len(state.tour), len(state.unvisited), 5) # Limit swaps\n    for _ in range(num_swaps):\n        i = rng.integers(0, len(state.tour)) if state.tour else None\n        j = rng.integers(0, len(state.unvisited)) if state.unvisited else None\n        if i is not None and j is not None:\n            node_in = state.unvisited[j]\n            node_out = state.tour[i]\n\n            # Evaluate the potential gain from swapping\n            prize_diff = DATA.prizes[node_in] - DATA.prizes[node_out]\n            penalty_diff = DATA.penalties[node_out] - DATA.penalties[node_in]\n\n            # Rough cost estimation (can be made more precise)\n            if len(state.tour) > 1:\n                idx = state.tour.index(node_out)\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost_diff = (np.linalg.norm(DATA.locations[node_in] - DATA.locations[prev_node]) + \\\n                             np.linalg.norm(DATA.locations[node_in] - DATA.locations[next_node]) - \\\n                             np.linalg.norm(DATA.locations[node_out] - DATA.locations[prev_node]) - \\\n                             np.linalg.norm(DATA.locations[node_out] - DATA.locations[next_node]))\n            else:\n                cost_diff = (2 * np.linalg.norm(DATA.locations[node_in] - DATA.depot) - \\\n                            2 * np.linalg.norm(DATA.locations[node_out] - DATA.depot))\n\n            gain = prize_diff - penalty_diff - cost_diff\n\n            if gain > 0:\n                state.remove(node_out)\n                state.unvisited.append(node_out)\n                state.opt_insert(node_in)\n                state.unvisited.remove(node_in)\n\n    return state",
    "objective": 11.823407491349101,
    "gap": -20.253002985169985,
    "runtime": 60.04097628593445,
    "timestamp": "2025-06-13 14:27:06",
    "feasible": true,
    "instance1_objective": 6.014561510729556,
    "instance2_objective": 5.808845980619546,
    "instance1_gap": -25.149460452339255,
    "instance2_gap": -15.356545518000717,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.6335959601441985,
    "strategy": "e2",
    "generation": 2
  },
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n    unvisited = state.unvisited[:]\n\n    # Sort unvisited nodes by a combination of prize-to-penalty ratio and distance to tour\n    def sorting_key(node):\n        closest_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                closest_dist = min(closest_dist, dist)\n        else:\n            closest_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n        return DATA.prizes[node] / (DATA.penalties[node] + 0.0001) - 0.01 * closest_dist\n\n    unvisited.sort(key=sorting_key, reverse=True)\n\n    for node in unvisited:\n        state.opt_insert(node)\n\n    # Ensure feasibility\n    while not state.is_feasible():\n        # Remove node with the lowest (prize - penalty) / cost ratio\n        worst_node = None\n        worst_ratio = float('inf')\n        for node in state.tour:\n            prize = DATA.prizes[node]\n            penalty = DATA.penalties[node]\n            idx = state.tour.index(node)\n            if len(state.tour) > 1:\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost = np.linalg.norm(DATA.locations[node] - DATA.locations[prev_node]) + \\\n                       np.linalg.norm(DATA.locations[node] - DATA.locations[next_node]) - \\\n                       np.linalg.norm(DATA.locations[prev_node] - DATA.locations[next_node])\n            else:\n                cost = 2 * np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n            ratio = (prize - penalty) / (cost + 0.0001)\n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        if worst_node is not None:\n            state.remove(worst_node)\n            state.unvisited.append(worst_node)\n\n    # Adaptive node swapping based on potential gain\n    num_swaps = min(len(state.tour), len(state.unvisited), 5)\n    for _ in range(num_swaps):\n        best_gain = 0\n        best_swap = None\n\n        for i in range(len(state.tour)):\n            for j in range(len(state.unvisited)):\n                node_in = state.unvisited[j]\n                node_out = state.tour[i]\n\n                # Evaluate the potential gain from swapping\n                prize_diff = DATA.prizes[node_in] - DATA.prizes[node_out]\n                penalty_diff = DATA.penalties[node_out] - DATA.penalties[node_in]\n\n                # More accurate cost estimation\n                idx = state.tour.index(node_out)\n                if len(state.tour) > 1:\n                    prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                    next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n\n                    cost_diff = (np.linalg.norm(DATA.locations[node_in] - DATA.locations[prev_node]) +\n                                 np.linalg.norm(DATA.locations[node_in] - DATA.locations[next_node]) -\n                                 np.linalg.norm(DATA.locations[node_out] - DATA.locations[prev_node]) -\n                                 np.linalg.norm(DATA.locations[node_out] - DATA.locations[next_node]))\n                else:\n                    cost_diff = (2 * np.linalg.norm(DATA.locations[node_in] - DATA.depot) -\n                                 2 * np.linalg.norm(DATA.locations[node_out] - DATA.depot))\n\n                gain = prize_diff - penalty_diff - cost_diff\n\n                if gain > best_gain:\n                    best_gain = gain\n                    best_swap = (i, j)\n\n        if best_swap is not None and best_gain > 0:\n            i, j = best_swap\n            node_in = state.unvisited[j]\n            node_out = state.tour[i]\n            \n            state.remove(node_out)\n            state.unvisited.append(node_out)\n            state.insert(node_in, i)  # insert at the same location that the node was removed from\n            state.unvisited.remove(node_in)\n        else:\n            break\n\n    return state",
    "objective": 11.887272919546646,
    "gap": -19.75630357415235,
    "runtime": 60.03661823272705,
    "timestamp": "2025-06-13 14:33:52",
    "feasible": true,
    "instance1_objective": 5.9850375363823956,
    "instance2_objective": 5.902235383164252,
    "instance1_gap": -25.5168829827322,
    "instance2_gap": -13.995724165572504,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.6335959601441994,
    "strategy": "e2",
    "generation": 4
  }
]