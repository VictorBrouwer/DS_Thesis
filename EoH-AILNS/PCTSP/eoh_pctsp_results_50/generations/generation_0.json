[
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n    unvisited = state.unvisited[:]\n    rng.shuffle(unvisited)\n\n    while unvisited:\n        node = unvisited.pop()\n        state.opt_insert(node)\n\n    # Ensure feasibility\n    while not state.is_feasible():\n        # Remove node with the lowest prize-to-cost ratio\n        worst_node = None\n        worst_ratio = float('inf')\n        for node in state.tour:\n            prize = DATA.prizes[node]\n            idx = state.tour.index(node)\n            if len(state.tour) > 1:\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost = np.linalg.norm(DATA.locations[node] - DATA.locations[prev_node]) + \\\n                       np.linalg.norm(DATA.locations[node] - DATA.locations[next_node])\n            else:\n                cost = 2 * np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n            ratio = prize / cost if cost > 0 else float('inf')\n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        if worst_node is not None:\n            state.remove(worst_node)\n            state.unvisited.append(worst_node)\n\n    return state",
    "objective": 11.983164989648794,
    "gap": -19.222074467391323,
    "runtime": 60.01540207862854,
    "timestamp": "2025-06-13 14:17:23",
    "feasible": true,
    "instance1_objective": 6.139665849104915,
    "instance2_objective": 5.843499140543878,
    "instance1_gap": -23.59255107325255,
    "instance2_gap": -14.851597861530093,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.633595960144199
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: PCTSPSolution, rng, **kwargs) -> PCTSPSolution:\n    unvisited = state.unvisited[:]\n    rng.shuffle(unvisited)\n    \n    current_prize = state.total_prize()\n    \n    # Insert nodes based on prize-to-penalty ratio and proximity to tour\n    while unvisited:\n        best_node = None\n        best_ratio = -1\n        \n        for node in unvisited:\n            ratio = DATA.prizes[node - 1] / DATA.penalties[node - 1]\n            \n            # Prioritize nodes with high prize/penalty ratio\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n        \n        if best_node is not None:\n            state.opt_insert(best_node)\n            current_prize = state.total_prize()\n            unvisited.remove(best_node)\n        else:\n            break\n            \n    # Enforce prize constraint\n    while not state.is_feasible():\n        # Find the node in the tour with the lowest prize-to-distance ratio\n        worst_node = None\n        worst_ratio = float('inf')\n\n        if not state.tour:\n            break\n\n        for node in state.tour:\n            # Calculate distance to nearest neighbor in tour\n            if len(state.tour) == 1:\n              distance = 2 * np.linalg.norm(DATA.locations[node - 1] - DATA.depot)\n            else:\n              idx = state.tour.index(node)\n              if idx == 0:\n                  distance = np.linalg.norm(DATA.locations[node - 1] - DATA.depot) + np.linalg.norm(DATA.locations[node - 1] - DATA.locations[state.tour[1] - 1])\n              elif idx == len(state.tour) - 1:\n                  distance = np.linalg.norm(DATA.locations[node - 1] - DATA.depot) + np.linalg.norm(DATA.locations[node - 1] - DATA.locations[state.tour[idx-1] - 1])\n              else:\n                  distance = np.linalg.norm(DATA.locations[node - 1] - DATA.locations[state.tour[idx-1] - 1]) + np.linalg.norm(DATA.locations[node - 1] - DATA.locations[state.tour[idx + 1] - 1])\n\n            ratio = DATA.prizes[node - 1] / distance\n            \n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        if worst_node is not None:\n            state.remove(worst_node)\n\n        else:\n            break\n\n    return state",
    "objective": 12.062221966154937,
    "gap": -18.66559378930959,
    "runtime": 60.042994022369385,
    "timestamp": "2025-06-13 14:19:35",
    "feasible": true,
    "instance1_objective": 6.158012331544065,
    "instance2_objective": 5.904209634610872,
    "instance1_gap": -23.364231168813582,
    "instance2_gap": -13.966956409805597,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.6335959601441985
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution in a smart way, ensures the solution collects enough prize,\n    and tries to minimize the total cost.\n    \"\"\"\n    unvisited = state.unvisited[:]\n    rng.shuffle(unvisited)\n\n    while unvisited:\n        best_node = None\n        best_cost_diff = float('inf')\n        best_insert_idx = None\n\n        for node in unvisited:\n            # Evaluate inserting this node at all possible positions in the tour\n            best_local_idx = None\n            best_local_cost_diff = float('inf')\n\n            for i in range(len(state.tour) + 1):\n                temp_tour = state.tour[:]\n                temp_tour.insert(i, node)\n                tour_cost = 0.0\n                \n                # Calculate cost of the new tour.  Distance is Euclidean distance\n                if len(temp_tour) > 0:\n                  start = DATA.depot\n                  for j in range(len(temp_tour)):\n                    end = DATA.locations[temp_tour[j]]\n                    tour_cost += np.linalg.norm(start - end)\n                    start = end\n                  tour_cost += np.linalg.norm(start - DATA.depot)\n\n\n                current_cost = state.objective()\n                \n                \n                unvisited_temp = state.unvisited[:]\n                if node in unvisited_temp:\n                  unvisited_temp.remove(node)\n\n                unvisited_penalty = sum([DATA.penalties[u] for u in unvisited_temp])\n                new_cost = tour_cost + unvisited_penalty\n\n                cost_diff = new_cost - current_cost\n\n                if cost_diff < best_local_cost_diff:\n                    best_local_cost_diff = cost_diff\n                    best_local_idx = i\n\n            # Update best node to insert\n            if best_local_cost_diff < best_cost_diff:\n                best_cost_diff = best_local_cost_diff\n                best_node = node\n                best_insert_idx = best_local_idx\n\n        # Insert the best node at the best location\n        if best_node is not None:\n            state.insert(best_node, best_insert_idx)\n            unvisited.remove(best_node)\n\n    # Enforce prize constraint by removing nodes with low prize-to-penalty ratio if necessary\n    while not state.is_feasible():\n        # Find the node with the lowest prize to penalty ratio in the tour\n        worst_node = None\n        worst_ratio = float('inf')\n        \n        if len(state.tour) == 0:\n          break\n\n        for node in state.tour:\n            ratio = DATA.prizes[node] / DATA.penalties[node]\n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        # Remove the worst node\n        if worst_node is not None:\n            state.remove(worst_node)\n    \n\n    return state",
    "objective": 12.347274841872117,
    "gap": -16.598939922079953,
    "runtime": 60.322502851486206,
    "timestamp": "2025-06-13 14:18:27",
    "feasible": true,
    "instance1_objective": 6.167573724336799,
    "instance2_objective": 6.179701117535318,
    "instance1_gap": -23.24524071405033,
    "instance2_gap": -9.952639130109578,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.633595960144199
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited[:]  # Create a copy to avoid modifying the original\n\n    # Sort unvisited nodes by prize-to-penalty ratio\n    prize_penalty_ratios = np.array([DATA.prizes[i] / DATA.penalties[i] for i in unvisited])\n    sorted_indices = np.argsort(prize_penalty_ratios)[::-1]\n    sorted_unvisited = [unvisited[i] for i in sorted_indices]\n\n    # Insert nodes until the prize constraint is met or all nodes are visited\n    while sorted_unvisited and not state.is_feasible():\n        node = sorted_unvisited.pop(0)\n        state.opt_insert(node)\n\n    # If the prize constraint is still not met, insert nodes with highest prizes\n    if not state.is_feasible():\n        unvisited = state.unvisited[:]\n        prizes = np.array([DATA.prizes[i] for i in unvisited])\n        sorted_indices = np.argsort(prizes)[::-1]\n        sorted_unvisited = [unvisited[i] for i in sorted_indices]\n\n        while sorted_unvisited and not state.is_feasible():\n            node = sorted_unvisited.pop(0)\n            state.opt_insert(node)\n            \n    # If still infeasible after inserting everything, add the highest prize nodes again until feasible\n    if not state.is_feasible():\n        unvisited_copy = list(range(DATA.size))\n        \n        prizes = np.array([DATA.prizes[i] for i in unvisited_copy])\n        sorted_indices = np.argsort(prizes)[::-1]\n        sorted_unvisited = [unvisited_copy[i] for i in sorted_indices]\n        \n        tour_set = set(state.tour)\n        missing = []\n        for node in sorted_unvisited:\n            if node not in tour_set:\n                missing.append(node)\n                \n        while missing and not state.is_feasible():\n            node = missing.pop(0)\n            if node not in state.tour: #check if the node is in the tour before inserting, otherwise it will add copies\n                state.opt_insert(node)    \n    \n    \n    # Attempt to improve the solution by iteratively inserting/removing nodes\n    for _ in range(5):\n        # Select a random node from the tour to potentially remove\n        if state.tour:\n            node_to_remove_idx = rng.choice(len(state.tour))\n            node_to_remove = state.tour[node_to_remove_idx]\n            \n            original_objective = state.objective()\n            \n            # Remove the selected node\n            state.remove(node_to_remove)\n            \n            # Check if inserting a different unvisited node is beneficial\n            unvisited = state.unvisited[:]\n            if unvisited:\n                # Sort unvisited nodes by prize-to-penalty ratio * proximity to the nearest tour node\n                proximity_scores = []\n                for unvisited_node in unvisited:\n                    distances = [np.linalg.norm(DATA.locations[tour_node] - DATA.locations[unvisited_node]) for tour_node in state.tour if state.tour]\n                    if distances:\n                         min_distance = min(distances)\n                    else:\n                        min_distance = np.linalg.norm(np.array(DATA.depot) - DATA.locations[unvisited_node])\n                    proximity_scores.append(DATA.prizes[unvisited_node] / DATA.penalties[unvisited_node] / (min_distance + 1e-6))\n\n                sorted_indices = np.argsort(proximity_scores)[::-1]\n\n                best_node_to_insert = unvisited[sorted_indices[0]]\n\n                state.opt_insert(best_node_to_insert)\n                \n                new_objective = state.objective()\n\n                if new_objective < original_objective and state.is_feasible():\n                    continue # Keep change if beneficial\n                else:\n                    # Revert to original state\n                    state.remove(best_node_to_insert)\n                    state.insert(node_to_remove, node_to_remove_idx)  # Re-insert at original location\n                    \n    return state",
    "objective": 15.54643727579939,
    "gap": 4.925325399494565,
    "runtime": 60.00613284111023,
    "timestamp": "2025-06-13 14:20:42",
    "feasible": true,
    "instance1_objective": 7.845371796341778,
    "instance2_objective": 7.701065479457611,
    "instance1_gap": -2.3652329665920284,
    "instance2_gap": 12.21588376558116,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 36,
    "prize_collected": 2.1077149112961617
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: PCTSPSolution, rng, **kwargs) -> PCTSPSolution:\n    \"\"\"\n    Repairs an infeasible PCTSP solution by re-inserting unvisited nodes and ensuring prize constraint satisfaction.\n    \"\"\"\n    DATA = kwargs[\"DATA\"]  # Access the DATA object from kwargs\n    \n    unvisited = list(state.unvisited)\n    rng.shuffle(unvisited)\n\n    while unvisited:\n        node = unvisited.pop(0)\n        best_insert_idx = -1\n        best_insert_cost = float('inf')\n        \n        #Find the cheapest insertion point for each unvisited node\n        for i in range(len(state.tour) + 1):\n            temp_tour = state.tour[:]\n            temp_tour.insert(i, node)\n            \n            cost = 0\n            for j in range(len(temp_tour)):\n                node1 = temp_tour[j]\n                node2 = temp_tour[(j+1)%len(temp_tour)]\n                \n                if j == len(temp_tour)-1:\n                    cost += np.linalg.norm(DATA.locations[node1-1] - DATA.locations[node2-1]) if len(temp_tour) > 1 else np.linalg.norm(DATA.depot - DATA.locations[node1-1])\n                else:\n                    cost += np.linalg.norm(DATA.locations[node1-1] - DATA.locations[node2-1]) \n                \n            if len(temp_tour) == 1:\n                cost += np.linalg.norm(DATA.depot - DATA.locations[node-1])\n                cost += np.linalg.norm(DATA.locations[node-1] - DATA.depot)\n\n            if len(temp_tour) > 0:\n                \n                if i == 0 :\n                    cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]-1])\n                \n                if i == len(state.tour):\n                    cost += np.linalg.norm(DATA.locations[temp_tour[-1]-1] - DATA.depot)\n\n            if cost < best_insert_cost:\n                best_insert_cost = cost\n                best_insert_idx = i\n        \n        if best_insert_idx != -1:\n            state.tour.insert(best_insert_idx, node)\n    \n    # Ensure prize constraint is met by iteratively removing the node with the lowest prize:penalty ratio\n    while state.total_prize() < DATA.total_prize and len(state.tour) > 0:\n        worst_node = -1\n        worst_ratio = float('inf')\n        \n        for node in state.tour:\n            ratio = DATA.prizes[node-1] / DATA.penalties[node-1]\n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n                \n        if worst_node != -1:\n            state.tour.remove(worst_node)\n            state.unvisited.append(worst_node)\n            \n    # Iterate and try to re-insert the nodes back with optimal insertion if prize limit allows, according to best_insert_cost\n    \n    for node in state.unvisited:\n        best_insert_idx = -1\n        best_insert_cost = float('inf')\n        \n        #Find the cheapest insertion point for each unvisited node\n        for i in range(len(state.tour) + 1):\n            temp_tour = state.tour[:]\n            temp_tour.insert(i, node)\n            \n            cost = 0\n            for j in range(len(temp_tour)):\n                node1 = temp_tour[j]\n                node2 = temp_tour[(j+1)%len(temp_tour)]\n                \n                if j == len(temp_tour)-1:\n                    cost += np.linalg.norm(DATA.locations[node1-1] - DATA.locations[node2-1]) if len(temp_tour) > 1 else np.linalg.norm(DATA.depot - DATA.locations[node1-1])\n                else:\n                    cost += np.linalg.norm(DATA.locations[node1-1] - DATA.locations[node2-1]) \n                \n            if len(temp_tour) == 1:\n                cost += np.linalg.norm(DATA.depot - DATA.locations[node-1])\n                cost += np.linalg.norm(DATA.locations[node-1] - DATA.depot)\n\n            if len(temp_tour) > 0:\n                \n                if i == 0 :\n                    cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]-1])\n                \n                if i == len(state.tour):\n                    cost += np.linalg.norm(DATA.locations[temp_tour[-1]-1] - DATA.depot)\n\n            if cost < best_insert_cost:\n                best_insert_cost = cost\n                best_insert_idx = i\n\n        if best_insert_idx != -1 and (state.total_prize() + DATA.prizes[node - 1] >= DATA.total_prize or (state.total_prize() < DATA.total_prize)):\n            state.tour.insert(best_insert_idx, node)\n            state.unvisited.remove(node)\n\n    return state",
    "objective": 29.796303178147014,
    "gap": 100.0,
    "runtime": 0.0,
    "timestamp": "2025-06-13 14:17:20",
    "feasible": false,
    "instance1_objective": 16.070856795627535,
    "instance2_objective": 13.725446382519479,
    "instance1_gap": 100.0,
    "instance2_gap": 100.0,
    "instance1_feasible": false,
    "instance2_feasible": false,
    "tour_length": 0,
    "prize_collected": 0
  }
]