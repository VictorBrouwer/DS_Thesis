[
  {
    "algorithm": "Modified version of: Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n    unvisited = state.unvisited[:]\n\n    # Sort unvisited nodes by prize-to-penalty ratio (high to low)\n    unvisited.sort(key=lambda node: DATA.prizes[node] / DATA.penalties[node], reverse=True)\n\n    for node in unvisited:\n        state.opt_insert(node)\n\n    # Ensure feasibility\n    while not state.is_feasible():\n        # Remove node with the lowest (prize - penalty) / cost ratio\n        worst_node = None\n        worst_ratio = float('inf')\n        for node in state.tour:\n            prize = DATA.prizes[node]\n            penalty = DATA.penalties[node]\n            idx = state.tour.index(node)\n            if len(state.tour) > 1:\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost = np.linalg.norm(DATA.locations[node] - DATA.locations[prev_node]) + \\\n                       np.linalg.norm(DATA.locations[node] - DATA.locations[next_node])\n            else:\n                cost = 2 * np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n            ratio = (prize - penalty) / cost if cost > 0 else float('inf')\n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        if worst_node is not None:\n            state.remove(worst_node)\n            state.unvisited.append(worst_node)\n            \n    # Try to improve by swapping nodes\n    for i in range(len(state.tour)):\n        for j in range(len(state.unvisited)):\n            node_in = state.unvisited[j]\n            node_out = state.tour[i]\n            \n            # Evaluate the potential gain from swapping\n            prize_diff = DATA.prizes[node_in] - DATA.prizes[node_out]\n            penalty_diff = DATA.penalties[node_out] - DATA.penalties[node_in]\n            \n            # Rough cost estimation (can be made more precise)\n            if len(state.tour) > 1:\n                idx = state.tour.index(node_out)\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost_diff = (np.linalg.norm(DATA.locations[node_in] - DATA.locations[prev_node]) + \\\n                             np.linalg.norm(DATA.locations[node_in] - DATA.locations[next_node]) - \\\n                             np.linalg.norm(DATA.locations[node_out] - DATA.locations[prev_node]) - \\\n                             np.linalg.norm(DATA.locations[node_out] - DATA.locations[next_node]))\n            else:\n                cost_diff = (2 * np.linalg.norm(DATA.locations[node_in] - DATA.depot) - \\\n                            2 * np.linalg.norm(DATA.locations[node_out] - DATA.depot))\n            \n            gain = prize_diff - penalty_diff - cost_diff\n            \n            if gain > 0:\n                state.remove(node_out)\n                state.unvisited.append(node_out)\n                state.opt_insert(node_in)\n                state.unvisited.remove(node_in)\n                break # Only swap one node per iteration to avoid instability\n\n    return state",
    "objective": 11.819084979153438,
    "gap": -20.279899573513923,
    "runtime": 60.02359390258789,
    "timestamp": "2025-06-13 14:23:54",
    "feasible": true,
    "instance1_objective": 6.010238998533892,
    "instance2_objective": 5.808845980619546,
    "instance1_gap": -25.20325362902713,
    "instance2_gap": -15.356545518000717,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.6335959601441985,
    "strategy": "m1",
    "generation": 1
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n    unvisited = state.unvisited[:]\n    rng.shuffle(unvisited)\n\n    while unvisited:\n        node = unvisited.pop()\n        state.opt_insert(node)\n\n    # Ensure feasibility\n    while not state.is_feasible():\n        # Remove node with the lowest prize-to-cost ratio\n        worst_node = None\n        worst_ratio = float('inf')\n        for node in state.tour:\n            prize = DATA.prizes[node]\n            idx = state.tour.index(node)\n            if len(state.tour) > 1:\n                prev_node = state.tour[idx - 1] if idx > 0 else state.tour[-1]\n                next_node = state.tour[idx + 1] if idx < len(state.tour) - 1 else state.tour[0]\n                cost = np.linalg.norm(DATA.locations[node] - DATA.locations[prev_node]) + \\\n                       np.linalg.norm(DATA.locations[node] - DATA.locations[next_node])\n            else:\n                cost = 2 * np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n            ratio = prize / cost if cost > 0 else float('inf')\n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        if worst_node is not None:\n            state.remove(worst_node)\n            state.unvisited.append(worst_node)\n\n    return state",
    "objective": 11.983164989648794,
    "gap": -19.222074467391323,
    "runtime": 60.01540207862854,
    "timestamp": "2025-06-13 14:17:23",
    "feasible": true,
    "instance1_objective": 6.139665849104915,
    "instance2_objective": 5.843499140543878,
    "instance1_gap": -23.59255107325255,
    "instance2_gap": -14.851597861530093,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.633595960144199
  },
  {
    "algorithm": "New PCTSP algorithm inspired by existing approaches but with different logic",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n    unvisited = state.unvisited[:]\n\n    # 1. Insert nodes based on a combination of prize and distance to nearest neighbor\n    while unvisited:\n        best_node = None\n        best_score = -1\n\n        for node in unvisited:\n            # Find nearest neighbor in the current tour\n            nearest_neighbor_dist = float('inf')\n            if state.tour:\n                for tour_node in state.tour:\n                    dist = np.linalg.norm(DATA.locations[node - 1] - DATA.locations[tour_node - 1])\n                    nearest_neighbor_dist = min(nearest_neighbor_dist, dist)\n            else:\n                nearest_neighbor_dist = np.linalg.norm(DATA.locations[node - 1] - DATA.depot)\n\n            # Calculate a score based on prize and distance\n            score = DATA.prizes[node - 1] / (nearest_neighbor_dist + 1e-6)  # Add a small epsilon to avoid division by zero\n\n            if score > best_score:\n                best_score = score\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n            unvisited.remove(best_node)\n        else:\n            break\n\n    # 2. Enforce prize constraint by iteratively adding nodes with the highest prize/penalty\n    while not state.is_feasible():\n        # Find the unvisited node with the highest prize-to-penalty ratio\n        best_node = None\n        best_ratio = -1\n\n        for node in state.unvisited:\n            ratio = DATA.prizes[node - 1] / (DATA.penalties[node - 1] + 1e-6)  # Avoid division by zero\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n            state.unvisited.remove(best_node)\n        else:\n            # If no unvisited node can help, remove the lowest prize node\n            worst_node = None\n            worst_prize = float('inf')\n            for node in state.tour:\n                if DATA.prizes[node - 1] < worst_prize:\n                    worst_prize = DATA.prizes[node - 1]\n                    worst_node = node\n            if worst_node is not None:\n                state.remove(worst_node)\n            else:\n                break # No node can be removed\n\n    return state",
    "objective": 12.027601283248302,
    "gap": -18.849290230823367,
    "runtime": 60.072081089019775,
    "timestamp": "2025-06-13 14:21:45",
    "feasible": true,
    "instance1_objective": 6.093551541464036,
    "instance2_objective": 5.934049741784266,
    "instance1_gap": -24.166438430066354,
    "instance2_gap": -13.532142031580381,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.6335959601441985,
    "strategy": "e1",
    "generation": 1
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: PCTSPSolution, rng, **kwargs) -> PCTSPSolution:\n    unvisited = state.unvisited[:]\n    rng.shuffle(unvisited)\n    \n    current_prize = state.total_prize()\n    \n    # Insert nodes based on prize-to-penalty ratio and proximity to tour\n    while unvisited:\n        best_node = None\n        best_ratio = -1\n        \n        for node in unvisited:\n            ratio = DATA.prizes[node - 1] / DATA.penalties[node - 1]\n            \n            # Prioritize nodes with high prize/penalty ratio\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n        \n        if best_node is not None:\n            state.opt_insert(best_node)\n            current_prize = state.total_prize()\n            unvisited.remove(best_node)\n        else:\n            break\n            \n    # Enforce prize constraint\n    while not state.is_feasible():\n        # Find the node in the tour with the lowest prize-to-distance ratio\n        worst_node = None\n        worst_ratio = float('inf')\n\n        if not state.tour:\n            break\n\n        for node in state.tour:\n            # Calculate distance to nearest neighbor in tour\n            if len(state.tour) == 1:\n              distance = 2 * np.linalg.norm(DATA.locations[node - 1] - DATA.depot)\n            else:\n              idx = state.tour.index(node)\n              if idx == 0:\n                  distance = np.linalg.norm(DATA.locations[node - 1] - DATA.depot) + np.linalg.norm(DATA.locations[node - 1] - DATA.locations[state.tour[1] - 1])\n              elif idx == len(state.tour) - 1:\n                  distance = np.linalg.norm(DATA.locations[node - 1] - DATA.depot) + np.linalg.norm(DATA.locations[node - 1] - DATA.locations[state.tour[idx-1] - 1])\n              else:\n                  distance = np.linalg.norm(DATA.locations[node - 1] - DATA.locations[state.tour[idx-1] - 1]) + np.linalg.norm(DATA.locations[node - 1] - DATA.locations[state.tour[idx + 1] - 1])\n\n            ratio = DATA.prizes[node - 1] / distance\n            \n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        if worst_node is not None:\n            state.remove(worst_node)\n\n        else:\n            break\n\n    return state",
    "objective": 12.062221966154937,
    "gap": -18.66559378930959,
    "runtime": 60.042994022369385,
    "timestamp": "2025-06-13 14:19:35",
    "feasible": true,
    "instance1_objective": 6.158012331544065,
    "instance2_objective": 5.904209634610872,
    "instance1_gap": -23.364231168813582,
    "instance2_gap": -13.966956409805597,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.6335959601441985
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution in a smart way, ensures the solution collects enough prize,\n    and tries to minimize the total cost.\n    \"\"\"\n    unvisited = state.unvisited[:]\n    rng.shuffle(unvisited)\n\n    while unvisited:\n        best_node = None\n        best_cost_diff = float('inf')\n        best_insert_idx = None\n\n        for node in unvisited:\n            # Evaluate inserting this node at all possible positions in the tour\n            best_local_idx = None\n            best_local_cost_diff = float('inf')\n\n            for i in range(len(state.tour) + 1):\n                temp_tour = state.tour[:]\n                temp_tour.insert(i, node)\n                tour_cost = 0.0\n                \n                # Calculate cost of the new tour.  Distance is Euclidean distance\n                if len(temp_tour) > 0:\n                  start = DATA.depot\n                  for j in range(len(temp_tour)):\n                    end = DATA.locations[temp_tour[j]]\n                    tour_cost += np.linalg.norm(start - end)\n                    start = end\n                  tour_cost += np.linalg.norm(start - DATA.depot)\n\n\n                current_cost = state.objective()\n                \n                \n                unvisited_temp = state.unvisited[:]\n                if node in unvisited_temp:\n                  unvisited_temp.remove(node)\n\n                unvisited_penalty = sum([DATA.penalties[u] for u in unvisited_temp])\n                new_cost = tour_cost + unvisited_penalty\n\n                cost_diff = new_cost - current_cost\n\n                if cost_diff < best_local_cost_diff:\n                    best_local_cost_diff = cost_diff\n                    best_local_idx = i\n\n            # Update best node to insert\n            if best_local_cost_diff < best_cost_diff:\n                best_cost_diff = best_local_cost_diff\n                best_node = node\n                best_insert_idx = best_local_idx\n\n        # Insert the best node at the best location\n        if best_node is not None:\n            state.insert(best_node, best_insert_idx)\n            unvisited.remove(best_node)\n\n    # Enforce prize constraint by removing nodes with low prize-to-penalty ratio if necessary\n    while not state.is_feasible():\n        # Find the node with the lowest prize to penalty ratio in the tour\n        worst_node = None\n        worst_ratio = float('inf')\n        \n        if len(state.tour) == 0:\n          break\n\n        for node in state.tour:\n            ratio = DATA.prizes[node] / DATA.penalties[node]\n            if ratio < worst_ratio:\n                worst_ratio = ratio\n                worst_node = node\n\n        # Remove the worst node\n        if worst_node is not None:\n            state.remove(worst_node)\n    \n\n    return state",
    "objective": 12.347274841872117,
    "gap": -16.598939922079953,
    "runtime": 60.322502851486206,
    "timestamp": "2025-06-13 14:18:27",
    "feasible": true,
    "instance1_objective": 6.167573724336799,
    "instance2_objective": 6.179701117535318,
    "instance1_gap": -23.24524071405033,
    "instance2_gap": -9.952639130109578,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 100,
    "prize_collected": 3.633595960144199
  }
]