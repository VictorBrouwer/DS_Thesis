{
  "algorithm": "Initial PCTSP repair operator generated from scratch",
  "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n    rng.shuffle(unvisited)\n\n    while unvisited:\n        node = unvisited.pop(0)\n\n        # Calculate the cost of inserting the node at the best position\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + np.linalg.norm(DATA.locations[node] - DATA.depot)\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[0]]) - np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[-1]]) + np.linalg.norm(DATA.locations[node] - DATA.depot) - np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx-1]]) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx]]) - np.linalg.norm(DATA.locations[state.tour[idx-1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n\n        # Check if inserting the node is beneficial\n        if best_insert_cost < DATA.penalties[node]:\n            state.insert(node, best_insert_idx)\n        else:\n            #Re-add the unvisited node since inserting it would make it infeasible\n            pass\n\n    # Ensure the solution collects enough prize\n    while state.total_prize() < DATA.total_prize:\n        # Find the node with the highest prize-to-penalty ratio among the unvisited nodes\n        best_node = -1\n        best_ratio = -1\n\n        unvisited = [i for i in range(DATA.size) if i not in state.tour]\n\n        if not unvisited:\n            break\n\n        for node in unvisited:\n            ratio = DATA.prizes[node] / DATA.penalties[node]\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n        \n        if best_node == -1:\n            break # No nodes left to add\n\n        # Insert the best node at the optimal position in the tour\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) + np.linalg.norm(DATA.locations[best_node] - DATA.depot)\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) + np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[0]]) - np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[-1]]) + np.linalg.norm(DATA.locations[best_node] - DATA.depot) - np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx-1]]) + np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx]]) - np.linalg.norm(DATA.locations[state.tour[idx-1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n\n        state.insert(best_node, best_insert_idx)\n\n    # Remove nodes to improve objective if possible\n    removed = True\n    while removed:\n        removed = False\n        for node in state.tour:\n            temp_tour = state.tour.copy()\n            temp_tour.remove(node)\n            \n            #If total prize collected is still enough\n            temp_prize = sum([DATA.prizes[i] for i in temp_tour])\n\n            if temp_prize >= DATA.total_prize:\n                # Calculate change in objective\n                \n                orig_len = 0\n                new_len = 0\n                \n                if len(state.tour) > 1:\n\n                    for i in range(len(state.tour)-1):\n                        if i == 0:\n                           orig_len += np.linalg.norm(DATA.locations[state.tour[i]] - DATA.depot)\n                        orig_len += np.linalg.norm(DATA.locations[state.tour[i]] - DATA.locations[state.tour[i+1]])\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                elif len(state.tour) == 1:\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n\n                if len(temp_tour) > 1:\n                    for i in range(len(temp_tour)-1):\n                        if i == 0:\n                           new_len += np.linalg.norm(DATA.locations[temp_tour[i]] - DATA.depot)\n                        new_len += np.linalg.norm(DATA.locations[temp_tour[i]] - DATA.locations[temp_tour[i+1]])\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                elif len(temp_tour) == 1:\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot)\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot)\n                    \n\n                delta_objective = DATA.penalties[node] + new_len - orig_len\n\n                if delta_objective < 0:\n                    state.remove(node)\n                    removed = True\n                    break\n    \n\n    return state",
  "objective": 3.2418847797978247,
  "gap": -32.99695477189122,
  "runtime": 0.22947311401367188,
  "timestamp": "2025-05-27 12:04:10",
  "feasible": true,
  "tour_length": 11,
  "prize_collected": 1.0330225068297527
}