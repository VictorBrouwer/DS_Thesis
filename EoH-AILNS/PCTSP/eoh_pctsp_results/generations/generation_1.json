[
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n    rng.shuffle(unvisited)\n\n    while unvisited:\n        node = unvisited.pop(0)\n\n        # Calculate the cost of inserting the node at the best position\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + np.linalg.norm(DATA.locations[node] - DATA.depot)\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[0]]) - np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[-1]]) + np.linalg.norm(DATA.locations[node] - DATA.depot) - np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx-1]]) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx]]) - np.linalg.norm(DATA.locations[state.tour[idx-1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n\n        # Check if inserting the node is beneficial\n        if best_insert_cost < DATA.penalties[node]:\n            state.insert(node, best_insert_idx)\n        else:\n            #Re-add the unvisited node since inserting it would make it infeasible\n            pass\n\n    # Ensure the solution collects enough prize\n    while state.total_prize() < DATA.total_prize:\n        # Find the node with the highest prize-to-penalty ratio among the unvisited nodes\n        best_node = -1\n        best_ratio = -1\n\n        unvisited = [i for i in range(DATA.size) if i not in state.tour]\n\n        if not unvisited:\n            break\n\n        for node in unvisited:\n            ratio = DATA.prizes[node] / DATA.penalties[node]\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n        \n        if best_node == -1:\n            break # No nodes left to add\n\n        # Insert the best node at the optimal position in the tour\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) + np.linalg.norm(DATA.locations[best_node] - DATA.depot)\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) + np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[0]]) - np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[-1]]) + np.linalg.norm(DATA.locations[best_node] - DATA.depot) - np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx-1]]) + np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx]]) - np.linalg.norm(DATA.locations[state.tour[idx-1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n\n        state.insert(best_node, best_insert_idx)\n\n    # Remove nodes to improve objective if possible\n    removed = True\n    while removed:\n        removed = False\n        for node in state.tour:\n            temp_tour = state.tour.copy()\n            temp_tour.remove(node)\n            \n            #If total prize collected is still enough\n            temp_prize = sum([DATA.prizes[i] for i in temp_tour])\n\n            if temp_prize >= DATA.total_prize:\n                # Calculate change in objective\n                \n                orig_len = 0\n                new_len = 0\n                \n                if len(state.tour) > 1:\n\n                    for i in range(len(state.tour)-1):\n                        if i == 0:\n                           orig_len += np.linalg.norm(DATA.locations[state.tour[i]] - DATA.depot)\n                        orig_len += np.linalg.norm(DATA.locations[state.tour[i]] - DATA.locations[state.tour[i+1]])\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                elif len(state.tour) == 1:\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n\n                if len(temp_tour) > 1:\n                    for i in range(len(temp_tour)-1):\n                        if i == 0:\n                           new_len += np.linalg.norm(DATA.locations[temp_tour[i]] - DATA.depot)\n                        new_len += np.linalg.norm(DATA.locations[temp_tour[i]] - DATA.locations[temp_tour[i+1]])\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                elif len(temp_tour) == 1:\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot)\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot)\n                    \n\n                delta_objective = DATA.penalties[node] + new_len - orig_len\n\n                if delta_objective < 0:\n                    state.remove(node)\n                    removed = True\n                    break\n    \n\n    return state",
    "objective": 3.2418847797978247,
    "gap": -32.99695477189122,
    "runtime": 0.22947311401367188,
    "timestamp": "2025-05-27 12:04:10",
    "feasible": true,
    "tour_length": 11,
    "prize_collected": 1.0330225068297527
  },
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n    rng.shuffle(unvisited)\n\n    # First, try to insert nodes based on cost benefit\n    while unvisited:\n        node = unvisited.pop(0)\n\n        # Calculate the cost of inserting the node at the best position\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) * 2\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[0]]) - np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[-1]]) + np.linalg.norm(DATA.locations[node] - DATA.depot) - np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx-1]]) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx]]) - np.linalg.norm(DATA.locations[state.tour[idx-1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n\n        # Check if inserting the node is beneficial\n        if best_insert_cost < DATA.penalties[node]:\n            state.insert(node, best_insert_idx)\n        #else:\n            # Re-add the unvisited node since inserting it would make it infeasible\n            # pass #no need to readd; just leave it unvisited\n\n    # Ensure the solution collects enough prize\n    if state.total_prize() < DATA.total_prize:\n        remaining_unvisited = [i for i in range(DATA.size) if i not in state.tour]\n\n        if remaining_unvisited:\n            while state.total_prize() < DATA.total_prize and remaining_unvisited:\n                # Find the node with the highest prize-to-penalty ratio among the unvisited nodes\n                best_node = -1\n                best_ratio = -1\n\n                for node in remaining_unvisited:\n                    ratio = DATA.prizes[node] / DATA.penalties[node]\n                    if ratio > best_ratio:\n                        best_ratio = ratio\n                        best_node = node\n                \n                if best_node == -1:\n                    break  # No nodes left to add\n\n                # Insert the best node at the optimal position in the tour\n                state.opt_insert(best_node)\n                remaining_unvisited.remove(best_node)\n\n\n\n    # Remove nodes to improve objective if possible\n    removed = True\n    while removed:\n        removed = False\n        for node in list(state.tour): # iterate over a copy of the tour since we might modify it\n            temp_tour = state.tour.copy()\n            temp_tour.remove(node)\n            \n            #If total prize collected is still enough\n            temp_prize = sum([DATA.prizes[i] for i in temp_tour])\n\n            if temp_prize >= DATA.total_prize:\n                # Calculate change in objective\n                \n                orig_len = 0\n                new_len = 0\n                \n                if len(state.tour) > 1:\n\n                    #Calculate original length\n                    if 0 in range(len(state.tour)):\n                        orig_len += np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n                    for i in range(len(state.tour)-1):\n                        orig_len += np.linalg.norm(DATA.locations[state.tour[i]] - DATA.locations[state.tour[i+1]])\n                        \n                    if len(state.tour)-1 in range(len(state.tour)):\n                        orig_len += np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n\n                elif len(state.tour) == 1:\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot) * 2\n\n\n                if len(temp_tour) > 1:\n                    #Calculate new length\n                    if 0 in range(len(temp_tour)):\n                        new_len += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot)\n                    \n                    for i in range(len(temp_tour)-1):\n                        new_len += np.linalg.norm(DATA.locations[temp_tour[i]] - DATA.locations[temp_tour[i+1]])\n                        \n                    if len(temp_tour)-1 in range(len(temp_tour)):\n                        new_len += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n\n\n                elif len(temp_tour) == 1:\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot) * 2\n                    \n\n                delta_objective = DATA.penalties[node] + new_len - orig_len\n\n                if delta_objective < 0:\n                    state.remove(node)\n                    removed = True\n                    break\n    \n\n    return state",
    "objective": 3.2418847797978247,
    "gap": -32.99695477189122,
    "runtime": 0.2596108913421631,
    "timestamp": "2025-05-27 12:04:38",
    "feasible": true,
    "tour_length": 11,
    "prize_collected": 1.0330225068297527,
    "strategy": "e2",
    "generation": 1
  },
  {
    "algorithm": "Modified version of: Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    # 1. Insert unvisited nodes based on insertion cost and prize/penalty ratio\n    unvisited = state.unvisited.copy()\n    rng.shuffle(unvisited)  # Shuffle to introduce some randomness\n\n    for node in unvisited:\n        # Calculate insertion cost at best position\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) * 2\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + \\\n                                  np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[0]]) - \\\n                                  np.linalg.norm(DATA.depot - DATA.locations[state.tour[0]])\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[-1]]) + \\\n                                  np.linalg.norm(DATA.locations[node] - DATA.depot) - \\\n                                  np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx - 1]]) + \\\n                                  np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx]]) - \\\n                                  np.linalg.norm(DATA.locations[state.tour[idx - 1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n\n        # Insertion criterion:  Consider prize/penalty ratio and insertion cost\n        if DATA.prizes[node] > 0 and best_insert_cost < DATA.penalties[node]: #Only if prize is greater than 0\n            state.insert(node, best_insert_idx)\n\n    # 2. Ensure feasibility (prize constraint)\n    while state.total_prize() < DATA.total_prize:\n        # Select node with highest (prize - insertion_cost)\n        best_node = -1\n        best_gain = -float('inf')\n\n        unvisited_nodes = [i for i in range(DATA.size) if i not in state.tour]\n        if not unvisited_nodes:\n            break\n\n        for node in unvisited_nodes:\n            # Calculate insertion cost\n            best_insert_cost = float('inf')\n            best_insert_idx = -1\n\n            if not state.tour:\n                best_insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) * 2\n                best_insert_idx = 0\n            else:\n                for idx in range(len(state.tour) + 1):\n                    if idx == 0:\n                        insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + \\\n                                      np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[0]]) - \\\n                                      np.linalg.norm(DATA.depot - DATA.locations[state.tour[0]])\n                    elif idx == len(state.tour):\n                        insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[-1]]) + \\\n                                      np.linalg.norm(DATA.locations[node] - DATA.depot) - \\\n                                      np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                    else:\n                        insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx - 1]]) + \\\n                                      np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx]]) - \\\n                                      np.linalg.norm(DATA.locations[state.tour[idx - 1]] - DATA.locations[state.tour[idx]])\n\n                    if insert_cost < best_insert_cost:\n                        best_insert_cost = insert_cost\n                        best_insert_idx = idx\n\n            gain = DATA.prizes[node] - best_insert_cost  # Prize - insertion cost\n\n            if gain > best_gain:\n                best_gain = gain\n                best_node = node\n\n        if best_node != -1:\n            # Insert the best node at its optimal position\n            best_insert_cost = float('inf')\n            best_insert_idx = -1\n\n            if not state.tour:\n                best_insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) * 2\n                best_insert_idx = 0\n            else:\n                for idx in range(len(state.tour) + 1):\n                    if idx == 0:\n                        insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) + \\\n                                      np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[0]]) - \\\n                                      np.linalg.norm(DATA.depot - DATA.locations[state.tour[0]])\n                    elif idx == len(state.tour):\n                        insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[-1]]) + \\\n                                      np.linalg.norm(DATA.locations[best_node] - DATA.depot) - \\\n                                      np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                    else:\n                        insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx - 1]]) + \\\n                                      np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx]]) - \\\n                                      np.linalg.norm(DATA.locations[state.tour[idx - 1]] - DATA.locations[state.tour[idx]])\n\n                    if insert_cost < best_insert_cost:\n                        best_insert_cost = insert_cost\n                        best_insert_idx = idx\n            state.insert(best_node, best_insert_idx)\n        else:\n            break\n\n    # 3. Local search: Remove nodes to reduce cost (if still feasible)\n    improved = True\n    while improved:\n        improved = False\n        for node in state.tour:\n            original_tour = state.tour.copy()\n            original_objective = state.objective()\n\n            state.remove(node) #Temporarily remove\n\n            if state.total_prize() >= DATA.total_prize: #Still Feasible\n                if state.objective() < original_objective: #Removing improves the objective\n                    improved = True\n                    break #Restart removal search\n                else:\n                    state.insert(node, original_tour.index(node)) #Undo the removal\n            else:\n                state.insert(node, original_tour.index(node)) #Undo the removal\n    \n\n    return state",
    "objective": 3.2882802387477126,
    "gap": -32.03805670932896,
    "runtime": 0.3232579231262207,
    "timestamp": "2025-05-27 12:04:49",
    "feasible": true,
    "tour_length": 11,
    "prize_collected": 1.0330225068297527,
    "strategy": "m1",
    "generation": 1
  },
  {
    "algorithm": "Simplified version of: Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Simplified repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n\n    # Insert unvisited nodes based on a simple cost-benefit analysis\n    for node in unvisited:\n        # Calculate the cost of inserting at the cheapest position\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) * 2  # Approximation for inserting into empty tour\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[0]]) - np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[-1]]) + np.linalg.norm(DATA.locations[node] - DATA.depot) - np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx - 1]]) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx]]) - np.linalg.norm(DATA.locations[state.tour[idx - 1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n\n        # Insert if insertion cost is less than the penalty\n        if best_insert_cost < DATA.penalties[node]:\n            state.insert(node, best_insert_idx)\n\n    # Ensure minimum prize is collected\n    while state.total_prize() < DATA.total_prize:\n        # Find unvisited nodes\n        remaining_unvisited = [i for i in range(DATA.size) if i not in state.tour]\n\n        if not remaining_unvisited:\n            break  # No more nodes to add\n\n        # Select node with highest prize (greedy approach)\n        best_node = max(remaining_unvisited, key=lambda x: DATA.prizes[x], default=-1)\n\n        if best_node == -1:\n            break\n        \n        # Insert at best location\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) * 2\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) + np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[0]]) - np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[-1]]) + np.linalg.norm(DATA.locations[best_node] - DATA.depot) - np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx - 1]]) + np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx]]) - np.linalg.norm(DATA.locations[state.tour[idx - 1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n        \n        state.insert(best_node, best_insert_idx)\n        \n\n    return state",
    "objective": 3.361706636044882,
    "gap": -30.52048512575586,
    "runtime": 0.1949479579925537,
    "timestamp": "2025-05-27 12:04:56",
    "feasible": true,
    "tour_length": 13,
    "prize_collected": 1.1096848939191617,
    "strategy": "m3",
    "generation": 1
  }
]