[
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n    rng.shuffle(unvisited)\n\n    while unvisited:\n        node = unvisited.pop(0)\n\n        # Calculate the cost of inserting the node at the best position\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + np.linalg.norm(DATA.locations[node] - DATA.depot)\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.depot) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[0]]) - np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[-1]]) + np.linalg.norm(DATA.locations[node] - DATA.depot) - np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx-1]]) + np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[idx]]) - np.linalg.norm(DATA.locations[state.tour[idx-1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n\n        # Check if inserting the node is beneficial\n        if best_insert_cost < DATA.penalties[node]:\n            state.insert(node, best_insert_idx)\n        else:\n            #Re-add the unvisited node since inserting it would make it infeasible\n            pass\n\n    # Ensure the solution collects enough prize\n    while state.total_prize() < DATA.total_prize:\n        # Find the node with the highest prize-to-penalty ratio among the unvisited nodes\n        best_node = -1\n        best_ratio = -1\n\n        unvisited = [i for i in range(DATA.size) if i not in state.tour]\n\n        if not unvisited:\n            break\n\n        for node in unvisited:\n            ratio = DATA.prizes[node] / DATA.penalties[node]\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n        \n        if best_node == -1:\n            break # No nodes left to add\n\n        # Insert the best node at the optimal position in the tour\n        best_insert_cost = float('inf')\n        best_insert_idx = -1\n\n        if not state.tour:\n            best_insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) + np.linalg.norm(DATA.locations[best_node] - DATA.depot)\n            best_insert_idx = 0\n        else:\n            for idx in range(len(state.tour) + 1):\n                if idx == 0:\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.depot) + np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[0]]) - np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                elif idx == len(state.tour):\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[-1]]) + np.linalg.norm(DATA.locations[best_node] - DATA.depot) - np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                else:\n                    insert_cost = np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx-1]]) + np.linalg.norm(DATA.locations[best_node] - DATA.locations[state.tour[idx]]) - np.linalg.norm(DATA.locations[state.tour[idx-1]] - DATA.locations[state.tour[idx]])\n\n                if insert_cost < best_insert_cost:\n                    best_insert_cost = insert_cost\n                    best_insert_idx = idx\n\n        state.insert(best_node, best_insert_idx)\n\n    # Remove nodes to improve objective if possible\n    removed = True\n    while removed:\n        removed = False\n        for node in state.tour:\n            temp_tour = state.tour.copy()\n            temp_tour.remove(node)\n            \n            #If total prize collected is still enough\n            temp_prize = sum([DATA.prizes[i] for i in temp_tour])\n\n            if temp_prize >= DATA.total_prize:\n                # Calculate change in objective\n                \n                orig_len = 0\n                new_len = 0\n                \n                if len(state.tour) > 1:\n\n                    for i in range(len(state.tour)-1):\n                        if i == 0:\n                           orig_len += np.linalg.norm(DATA.locations[state.tour[i]] - DATA.depot)\n                        orig_len += np.linalg.norm(DATA.locations[state.tour[i]] - DATA.locations[state.tour[i+1]])\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[-1]] - DATA.depot)\n                elif len(state.tour) == 1:\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n                    orig_len += np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n\n                if len(temp_tour) > 1:\n                    for i in range(len(temp_tour)-1):\n                        if i == 0:\n                           new_len += np.linalg.norm(DATA.locations[temp_tour[i]] - DATA.depot)\n                        new_len += np.linalg.norm(DATA.locations[temp_tour[i]] - DATA.locations[temp_tour[i+1]])\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                elif len(temp_tour) == 1:\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot)\n                    new_len += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot)\n                    \n\n                delta_objective = DATA.penalties[node] + new_len - orig_len\n\n                if delta_objective < 0:\n                    state.remove(node)\n                    removed = True\n                    break\n    \n\n    return state",
    "objective": 3.2418847797978247,
    "gap": -32.99695477189122,
    "runtime": 0.22947311401367188,
    "timestamp": "2025-05-27 12:04:10",
    "feasible": true,
    "tour_length": 11,
    "prize_collected": 1.0330225068297527
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n\n    Inserts the unvisited nodes back into the solution in a smart way, ensuring the solution\n    collects enough prize and minimizes the total cost.\n    \"\"\"\n\n    unvisited = list(state.unvisited)\n    rng.shuffle(unvisited)\n\n    while unvisited:\n        node = unvisited.pop(0)\n        state.opt_insert(node)\n\n        if state.total_prize() >= DATA.total_prize:\n            break\n\n    # If the solution is still infeasible, add nodes greedily based on prize-to-penalty ratio\n    if not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            return state",
    "objective": 9.676828176274608,
    "gap": 100.0,
    "runtime": 0.0,
    "timestamp": "2025-05-27 12:04:13",
    "feasible": false,
    "tour_length": 0,
    "prize_collected": 0
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repairs a PCTSP solution by re-inserting unvisited nodes and ensuring feasibility.\n    \"\"\"\n\n    unvisited_nodes = state.unvisited[:]\n    rng.shuffle(unvisited_nodes)\n\n    # Calculate prize-to-penalty ratios for unvisited nodes\n    prize_penalty_ratios = {node: DATA.prizes[node] / DATA.penalties[node] for node in unvisited_nodes}\n\n    # Sort unvisited nodes by prize-to-penalty ratio (descending)\n    sorted_unvisited = sorted(unvisited_nodes, key=lambda node: prize_penalty_ratios[node], reverse=True)\n\n    # Greedily insert nodes until prize constraint is met\n    for node in sorted_unvisited:\n        best_insert_idx = -1\n        best_insert_cost = float('inf')\n\n        if len(state.tour) == 0:\n            #Insert into empty tour\n            state.insert(node, 0)\n            state.unvisited.remove(node)\n            continue\n        \n        for i in range(len(state.tour) + 1):\n            # Calculate cost of inserting node at index i\n            temp_tour = state.tour[:]\n            temp_tour.insert(i, node)\n\n            tour_cost = 0.0\n            if len(temp_tour) > 1:\n                for j in range(len(temp_tour) - 1):\n                    tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n            elif len(temp_tour) == 1:\n                tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                tour_cost += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot)\n            \n            \n            current_prize = state.total_prize()\n            cost = tour_cost - state.objective() + DATA.penalties[node]\n            \n            if cost < best_insert_cost:\n                best_insert_cost = cost\n                best_insert_idx = i\n        \n        if best_insert_idx != -1:\n            state.insert(node, best_insert_idx)\n            state.unvisited.remove(node)\n\n    # Check if prize constraint is met\n    if not state.is_feasible():\n        # If not feasible, add nodes with highest prize-to-penalty ratio until feasible\n        remaining_unvisited = state.unvisited[:]\n        rng.shuffle(remaining_unvisited)\n\n        prize_penalty_ratios = {node: DATA.prizes[node] / DATA.penalties[node] for node in remaining_unvisited}\n        sorted_unvisited = sorted(remaining_unvisited, key=lambda node: prize_penalty_ratios[node], reverse=True)\n\n        for node in sorted_unvisited:\n            state.opt_insert(node)\n            state.unvisited.remove(node)\n            if state.is_feasible():\n                break\n\n    return state",
    "objective": 9.676828176274608,
    "gap": 100.0,
    "runtime": 0.0,
    "timestamp": "2025-05-27 12:04:17",
    "feasible": false,
    "tour_length": 0,
    "prize_collected": 0
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: PCTSPSolution, rng, **kwargs) -> PCTSPSolution:\n    \"\"\"\n    Repairs a PCTSP solution by re-inserting unvisited nodes and ensuring feasibility.\n\n    Args:\n        state: The current PCTSPSolution.\n        rng: A numpy.random.Generator object for random operations.\n\n    Returns:\n        The repaired PCTSPSolution.\n    \"\"\"\n    unvisited_nodes = state.unvisited[:]\n    rng.shuffle(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        state.opt_insert(node)\n\n    while not state.is_feasible():\n        # Remove a low prize/penalty node to make room for high-prize nodes\n\n        if len(state.tour) == 0:\n            # Handle empty tour case\n            return state",
    "objective": 9.676828176274608,
    "gap": 100.0,
    "runtime": 0.0,
    "timestamp": "2025-05-27 12:04:22",
    "feasible": false,
    "tour_length": 0,
    "prize_collected": 0
  }
]