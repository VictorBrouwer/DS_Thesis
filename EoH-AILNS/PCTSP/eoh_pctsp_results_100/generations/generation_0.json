[
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution in a smart way, ensuring the solution collects enough prize.\n    \"\"\"\n\n    unvisited_nodes = list(state.unvisited)\n    rng.shuffle(unvisited_nodes)\n\n    # Calculate prize-to-penalty ratio for each unvisited node\n    prize_penalty_ratios = {node: DATA.prizes[node] / DATA.penalties[node] for node in unvisited_nodes}\n\n    # Sort unvisited nodes by prize-to-penalty ratio in descending order\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: prize_penalty_ratios[node], reverse=True)\n\n    for node in sorted_nodes:\n        # Try inserting the node at the best possible location in the tour\n        best_insert_idx = -1\n        best_insert_cost = float('inf')\n\n        for i in range(len(state.tour) + 1):\n            temp_tour = list(state.tour)\n            temp_tour.insert(i, node)\n            \n            tour_cost = 0.0\n            if len(temp_tour) > 0:\n                start = DATA.depot\n                for j in range(len(temp_tour)):\n                    end = DATA.locations[temp_tour[j]]\n                    tour_cost += np.linalg.norm(start - end)\n                    start = end\n                tour_cost += np.linalg.norm(start - DATA.depot)\n                \n            current_penalty = sum(DATA.penalties[n] for n in state.unvisited if n != node)\n            temp_cost = tour_cost + current_penalty\n            \n            if temp_cost < best_insert_cost:\n                best_insert_cost = temp_cost\n                best_insert_idx = i\n\n        # Insert the node at the best location if it improves the cost\n        if best_insert_idx != -1:\n            state.opt_insert(node)\n\n    # If the solution is still infeasible, greedily insert nodes until it becomes feasible\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break\n\n        best_node = None\n        best_prize_penalty_ratio = -1\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / DATA.penalties[node]\n            if ratio > best_prize_penalty_ratio:\n                best_prize_penalty_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break\n\n    return state",
    "objective": 17.55732648238738,
    "gap": -3.7343265705531543,
    "runtime": 60.16460871696472,
    "timestamp": "2025-06-13 16:41:52",
    "feasible": true,
    "instance1_objective": 9.218219462663203,
    "instance2_objective": 8.33910701972418,
    "instance1_gap": -3.720155899729593,
    "instance2_gap": -3.748497241376716,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 200,
    "prize_collected": 4.1363912134368785
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: PCTSPSolution, rng, **kwargs) -> PCTSPSolution:\n    \"\"\"\n    Repairs a PCTSP solution by re-inserting unvisited nodes to meet the prize requirement and minimize cost.\n    \"\"\"\n    unvisited = state.unvisited.copy()\n    tour = state.tour.copy()\n\n    # Calculate prize-to-penalty ratio for each node\n    prize_penalty_ratio = DATA.prizes / DATA.penalties\n\n    # Sort unvisited nodes by prize-to-penalty ratio (descending)\n    unvisited_sorted = sorted(unvisited, key=lambda node: prize_penalty_ratio[node], reverse=True)\n\n    # Insert nodes until the prize constraint is met or all nodes are inserted\n    while not state.is_feasible() and unvisited_sorted:\n        best_node = None\n        best_insertion_cost = float('inf')\n\n        for node in unvisited_sorted:\n            # Evaluate insertion cost at different positions\n            for idx in range(len(tour) + 1):\n                temp_tour = tour[:]\n                temp_tour.insert(idx, node)\n                \n                tour_cost = 0.0\n                if len(temp_tour) > 1:\n                    for i in range(len(temp_tour) - 1):\n                        tour_cost += np.linalg.norm(DATA.locations[temp_tour[i]] - DATA.locations[temp_tour[i+1]])\n                    tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                    tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                elif len(temp_tour) == 1:\n                    tour_cost += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot) * 2\n                    \n\n                temp_unvisited = [n for n in unvisited if n != node]\n                penalty_cost = np.sum(DATA.penalties[temp_unvisited])\n                \n                total_cost = tour_cost + penalty_cost\n\n                if total_cost < best_insertion_cost:\n                    best_insertion_cost = total_cost\n                    best_node = node\n                    best_insertion_index = idx\n        \n        if best_node is not None:\n            tour.insert(best_insertion_index, best_node)\n            unvisited_sorted.remove(best_node)\n        else:\n            break # No node could be inserted to improve the cost\n\n    # If still infeasible, force-insert nodes with highest prize until feasible\n    if not state.is_feasible():\n        unvisited_sorted = sorted(unvisited, key=lambda node: DATA.prizes[node], reverse=True)\n        while not state.is_feasible() and unvisited_sorted:\n            node = unvisited_sorted.pop(0)\n            # Find best insertion position for the node\n            best_idx = 0\n            best_insertion_cost = float('inf')\n            for idx in range(len(tour) + 1):\n                temp_tour = tour[:]\n                temp_tour.insert(idx, node)\n\n                tour_cost = 0.0\n                if len(temp_tour) > 1:\n                    for i in range(len(temp_tour) - 1):\n                        tour_cost += np.linalg.norm(DATA.locations[temp_tour[i]] - DATA.locations[temp_tour[i+1]])\n                    tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                    tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                elif len(temp_tour) == 1:\n                    tour_cost += np.linalg.norm(DATA.locations[temp_tour[0]] - DATA.depot) * 2\n                    \n\n                temp_unvisited = [n for n in unvisited if n != node]\n                penalty_cost = np.sum(DATA.penalties[temp_unvisited])\n                total_cost = tour_cost + penalty_cost\n                \n                if total_cost < best_insertion_cost:\n                    best_insertion_cost = total_cost\n                    best_idx = idx\n\n            tour.insert(best_idx, node)\n\n    \n    state.tour = tour\n    state.unvisited = [node for node in range(DATA.size) if node not in state.tour]\n    return state",
    "objective": 18.28204204558714,
    "gap": 0.35211412680725596,
    "runtime": 67.61674904823303,
    "timestamp": "2025-06-13 16:43:11",
    "feasible": true,
    "instance1_objective": 9.39306169919536,
    "instance2_objective": 8.888980346391781,
    "instance1_gap": -1.8940132977183233,
    "instance2_gap": 2.598241551332835,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 382,
    "prize_collected": 7.868127222719151
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: PCTSPSolution, rng, **kwargs) -> PCTSPSolution:\n    unvisited_nodes = state.unvisited[:]\n    rng.shuffle(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        state.opt_insert(node)\n\n    while not state.is_feasible():\n        # Remove the node with the lowest prize-to-penalty ratio to make room for higher prize nodes\n        if not state.tour:\n            return state",
    "objective": 36.47654834519642,
    "gap": 100.0,
    "runtime": 0.0,
    "timestamp": "2025-06-13 16:42:56",
    "feasible": false,
    "instance1_objective": 19.148804298151774,
    "instance2_objective": 17.327744047044646,
    "instance1_gap": 100.0,
    "instance2_gap": 100.0,
    "instance1_feasible": false,
    "instance2_feasible": false,
    "tour_length": 0,
    "prize_collected": 0
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n\n    Inserts the unvisited nodes back into the solution in a smart way,\n    ensuring the solution collects enough prize and minimizing the total cost.\n    \"\"\"\n\n    unvisited_nodes = state.unvisited.copy()\n    rng.shuffle(unvisited_nodes)\n\n    while unvisited_nodes:\n        best_node = None\n        best_objective = float('inf')\n        best_insertion_idx = None\n\n        for node in unvisited_nodes:\n            temp_state = state.copy()\n            best_local_objective = float('inf')\n            best_local_idx = None\n\n            for i in range(len(temp_state.tour) + 1):\n                temp_state.insert(node, i)\n                objective = temp_state.objective()\n                if objective < best_local_objective:\n                    best_local_objective = objective\n                    best_local_idx = i\n                temp_state = state.copy()  # Reset to original state\n\n            if best_local_objective < best_objective:\n                best_objective = best_local_objective\n                best_node = node\n                best_insertion_idx = best_local_idx\n\n        if best_node is not None:\n            state.insert(best_node, best_insertion_idx)\n            unvisited_nodes.remove(best_node)\n        else:\n            break  # No improvement possible, exit loop\n\n    # Ensure feasibility by adding nodes until enough prize is collected\n    while not state.is_feasible():\n        best_node = None\n        best_prize_ratio = -float('inf')\n\n        for node in DATA.locations:\n            node_idx = np.where((DATA.locations == node).all(axis=1))[0][0]\n            if node_idx in state.tour:\n                continue\n            if node_idx not in state.unvisited:\n                continue\n\n            prize_ratio = DATA.prizes[node_idx] / DATA.penalties[node_idx]\n            if prize_ratio > best_prize_ratio:\n                best_prize_ratio = prize_ratio\n                best_node = node_idx\n\n        if best_node is not None:\n            state.opt_insert(best_node)  # Use optimal insertion\n\n        state.unvisited = [n for n in range(DATA.size) if n not in state.tour]\n        \n        if len(state.unvisited) == 0 and not state.is_feasible():\n            \n            lowest_penalty_node = None\n            lowest_penalty = float('inf')\n            for node in state.tour:\n                penalty = DATA.penalties[node]\n                if penalty < lowest_penalty:\n                    lowest_penalty = penalty\n                    lowest_penalty_node = node\n            \n            if lowest_penalty_node is not None:\n                state.remove(lowest_penalty_node)\n                state.unvisited = [n for n in range(DATA.size) if n not in state.tour]\n            else:\n                break\n\n        if best_node is None:\n            break\n\n    return state",
    "objective": 36.47654834519642,
    "gap": 100.0,
    "runtime": 0.0,
    "timestamp": "2025-06-13 16:43:02",
    "feasible": false,
    "instance1_objective": 19.148804298151774,
    "instance2_objective": 17.327744047044646,
    "instance1_gap": 100.0,
    "instance2_gap": 100.0,
    "instance1_feasible": false,
    "instance2_feasible": false,
    "tour_length": 0,
    "prize_collected": 0
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution in a smart way, ensures the solution collects enough prize,\n    and tries to minimize the total cost.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n    rng.shuffle(unvisited)\n    \n    while unvisited:\n        node = unvisited.pop(0)\n        state.opt_insert(node)\n        \n        if state.total_prize() >= DATA.total_prize:\n            break\n\n    # If still infeasible, add nodes with highest prize/penalty ratio until feasible\n    if state.total_prize() < DATA.total_prize:\n        nodes_with_ratios = []\n        for node in state.unvisited:\n            nodes_with_ratios.append((node, DATA.prizes[node] / DATA.penalties[node]))\n\n        nodes_with_ratios.sort(key=lambda x: x[1], reverse=True)\n\n        for node, _ in nodes_with_ratios:\n            state.opt_insert(node)\n            if state.total_prize() >= DATA.total_prize:\n                break\n    \n    # Remove unnecessary nodes to minimize cost after feasibility is achieved\n    if state.total_prize() >= DATA.total_prize:\n        \n        for i in range(len(state.tour)):\n            node = state.tour[i]\n            \n            original_tour = state.tour.copy()\n            original_unvisited = state.unvisited.copy()\n            \n            removed_node = state.remove(node)\n            \n            if state.total_prize() >= DATA.total_prize:\n                continue\n            else:\n                state.tour = original_tour\n                state.unvisited = original_unvisited\n                \n\n    return state",
    "objective": 36.47654834519642,
    "gap": 100.0,
    "runtime": 0.0,
    "timestamp": "2025-06-13 16:43:05",
    "feasible": false,
    "instance1_objective": 19.148804298151774,
    "instance2_objective": 17.327744047044646,
    "instance1_gap": 100.0,
    "instance2_gap": 100.0,
    "instance1_feasible": false,
    "instance2_feasible": false,
    "tour_length": 0,
    "prize_collected": 0
  }
]