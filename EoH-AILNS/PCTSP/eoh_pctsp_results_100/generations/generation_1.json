[
  {
    "algorithm": "New PCTSP algorithm inspired by existing approaches but with different logic",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution based on a combination of distance and prize.\n    \"\"\"\n    unvisited_nodes = list(state.unvisited)\n    \n    # Calculate distance to the closest node in the tour for each unvisited node\n    distances = {}\n    for node in unvisited_nodes:\n        min_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                min_dist = min(min_dist, dist)\n            dist_to_depot1 = np.linalg.norm(DATA.locations[node] - DATA.depot)\n            dist_to_depot2 = np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n        else:\n            min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        distances[node] = min_dist\n\n    # Combine prize and distance to prioritize nodes\n    priority = {node: DATA.prizes[node] / (distances[node] + 1e-6) for node in unvisited_nodes}\n\n    # Sort unvisited nodes based on priority\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: priority[node], reverse=True)\n\n    # Insert nodes into the tour until feasible or no more nodes to insert\n    while not state.is_feasible() and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        \n        # Find the best insertion point based on minimizing tour length increase\n        best_idx = -1\n        min_increase = float('inf')\n        \n        if state.tour:\n            for i in range(len(state.tour) + 1):\n                temp_tour = list(state.tour)\n                temp_tour.insert(i, node)\n                \n                tour_length = 0\n                start_node = DATA.depot\n                for j in range(len(temp_tour)):\n                    end_node = DATA.locations[temp_tour[j]]\n                    tour_length += np.linalg.norm(start_node - end_node)\n                    start_node = end_node\n                tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                original_tour_length = 0\n                start_node = DATA.depot\n                for j in range(len(state.tour)):\n                    end_node = DATA.locations[state.tour[j]]\n                    original_tour_length += np.linalg.norm(start_node - end_node)\n                    start_node = end_node\n                original_tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                increase = tour_length - original_tour_length\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_idx = i\n        else:\n                best_idx = 0 #Insert at start\n\n        state.insert(node, best_idx)\n    \n\n    # If still infeasible, add the node with the highest prize to penalty ratio\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break\n            \n        best_node = None\n        best_ratio = -1\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / (DATA.penalties[node] + 1e-6)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break\n            \n    return state",
    "objective": 14.422278216998588,
    "gap": -20.647907669172188,
    "runtime": 60.012267112731934,
    "timestamp": "2025-06-13 16:44:24",
    "feasible": true,
    "instance1_objective": 7.069899610537622,
    "instance2_objective": 7.352378606460966,
    "instance1_gap": -26.1583177679663,
    "instance2_gap": -15.137497570378075,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 52,
    "prize_collected": 2.030564893762092,
    "strategy": "e1",
    "generation": 1
  },
  {
    "algorithm": "Simplified version of: Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Aims for simplicity and robustness.\n    \"\"\"\n\n    unvisited_nodes = list(state.unvisited)\n    rng.shuffle(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        state.opt_insert(node)\n\n    # If the solution is still infeasible, greedily insert nodes until it becomes feasible\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            # No more nodes to insert, repair failed.\n            break\n\n        # Prioritize inserting nodes with high prize\n        best_node = max(remaining_unvisited, key=lambda n: DATA.prizes[n])\n        state.opt_insert(best_node)\n\n    return state",
    "objective": 17.24255803594884,
    "gap": -5.353874591537096,
    "runtime": 60.17847967147827,
    "timestamp": "2025-06-13 16:47:46",
    "feasible": true,
    "instance1_objective": 8.859258972267789,
    "instance2_objective": 8.38329906368105,
    "instance1_gap": -7.46932461863557,
    "instance2_gap": -3.238424564438623,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 200,
    "prize_collected": 4.1363912134368785,
    "strategy": "m3",
    "generation": 1
  },
  {
    "algorithm": "Modified version of: Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution in a smart way, ensuring the solution collects enough prize.\n    \"\"\"\n\n    unvisited_nodes = list(state.unvisited)\n\n    # Calculate prize-to-cost ratio, considering distance to the tour\n    node_scores = {}\n    for node in unvisited_nodes:\n        min_dist_to_tour = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                min_dist_to_tour = min(min_dist_to_tour, dist)\n            dist_to_depot_start = np.linalg.norm(DATA.locations[node] - DATA.depot)\n            dist_to_depot_end = np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[-1]])\n            min_dist_to_tour = min(min_dist_to_tour, dist_to_depot_start, dist_to_depot_end)\n\n        else:\n            min_dist_to_tour = np.linalg.norm(DATA.locations[node] - DATA.depot)\n        \n        # Prioritize nodes with high prize and low penalty, and that are close to the existing tour\n        node_scores[node] = (DATA.prizes[node] / DATA.penalties[node]) / (min_dist_to_tour + 1e-6)\n\n    # Sort unvisited nodes by score in descending order\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: node_scores[node], reverse=True)\n\n    for node in sorted_nodes:\n        state.opt_insert(node)  # Insert optimally based on current state of tour\n\n    # If the solution is still infeasible, prioritize nodes based purely on prize until feasible\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break\n\n        best_node = None\n        best_prize = -1\n        for node in remaining_unvisited:\n            if DATA.prizes[node] > best_prize:\n                best_prize = DATA.prizes[node]\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break  # No more nodes to add, repair failed.\n\n    return state",
    "objective": 17.296552212530727,
    "gap": -5.052222405049387,
    "runtime": 60.31734085083008,
    "timestamp": "2025-06-13 16:46:44",
    "feasible": true,
    "instance1_objective": 8.877394085906884,
    "instance2_objective": 8.419158126623845,
    "instance1_gap": -7.279912127320423,
    "instance2_gap": -2.8245326827783512,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 200,
    "prize_collected": 4.1363912134368785,
    "strategy": "m1",
    "generation": 1
  },
  {
    "algorithm": "Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution in a smart way, ensuring the solution collects enough prize.\n    \"\"\"\n\n    unvisited_nodes = list(state.unvisited)\n    rng.shuffle(unvisited_nodes)\n\n    # Calculate prize-to-penalty ratio for each unvisited node\n    prize_penalty_ratios = {node: DATA.prizes[node] / DATA.penalties[node] for node in unvisited_nodes}\n\n    # Sort unvisited nodes by prize-to-penalty ratio in descending order\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: prize_penalty_ratios[node], reverse=True)\n\n    for node in sorted_nodes:\n        # Try inserting the node at the best possible location in the tour\n        best_insert_idx = -1\n        best_insert_cost = float('inf')\n\n        for i in range(len(state.tour) + 1):\n            temp_tour = list(state.tour)\n            temp_tour.insert(i, node)\n            \n            tour_cost = 0.0\n            if len(temp_tour) > 0:\n                start = DATA.depot\n                for j in range(len(temp_tour)):\n                    end = DATA.locations[temp_tour[j]]\n                    tour_cost += np.linalg.norm(start - end)\n                    start = end\n                tour_cost += np.linalg.norm(start - DATA.depot)\n                \n            current_penalty = sum(DATA.penalties[n] for n in state.unvisited if n != node)\n            temp_cost = tour_cost + current_penalty\n            \n            if temp_cost < best_insert_cost:\n                best_insert_cost = temp_cost\n                best_insert_idx = i\n\n        # Insert the node at the best location if it improves the cost\n        if best_insert_idx != -1:\n            state.opt_insert(node)\n\n    # If the solution is still infeasible, greedily insert nodes until it becomes feasible\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break\n\n        best_node = None\n        best_prize_penalty_ratio = -1\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / DATA.penalties[node]\n            if ratio > best_prize_penalty_ratio:\n                best_prize_penalty_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break\n\n    return state",
    "objective": 17.55732648238738,
    "gap": -3.7343265705531543,
    "runtime": 60.16460871696472,
    "timestamp": "2025-06-13 16:41:52",
    "feasible": true,
    "instance1_objective": 9.218219462663203,
    "instance2_objective": 8.33910701972418,
    "instance1_gap": -3.720155899729593,
    "instance2_gap": -3.748497241376716,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 200,
    "prize_collected": 4.1363912134368785
  },
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution in a smart way, ensuring the solution collects enough prize.\n    \"\"\"\n\n    unvisited = list(state.unvisited)\n\n    # Calculate prize-to-penalty ratio for each unvisited node\n    prize_penalty_ratios = {node: DATA.prizes[node] / DATA.penalties[node] for node in unvisited}\n\n    # Sort unvisited nodes by prize-to-penalty ratio in descending order\n    sorted_nodes = sorted(unvisited, key=lambda node: prize_penalty_ratios[node], reverse=True)\n\n    # Insert nodes based on prize-to-penalty until feasible or all nodes are considered\n    tour = list(state.tour)  # Create a copy to avoid modifying the original state\n    unvisited_remaining = list(sorted_nodes)\n    \n    while not state.is_feasible() and unvisited_remaining:\n        best_node = None\n        best_insert_idx = -1\n        best_insert_cost = float('inf')\n\n        for node in unvisited_remaining:\n            for i in range(len(tour) + 1):\n                temp_tour = list(tour)\n                temp_tour.insert(i, node)\n\n                tour_cost = 0.0\n                if len(temp_tour) > 0:\n                    start = DATA.depot\n                    for j in range(len(temp_tour)):\n                        end = DATA.locations[temp_tour[j]]\n                        tour_cost += np.linalg.norm(start - end)\n                        start = end\n                    tour_cost += np.linalg.norm(start - DATA.depot)\n\n                current_penalty = sum(DATA.penalties[n] for n in unvisited_remaining if n != node)\n                temp_cost = tour_cost + current_penalty\n\n                if temp_cost < best_insert_cost:\n                    best_insert_cost = temp_cost\n                    best_insert_idx = i\n                    best_node = node\n\n        if best_node is not None:\n            tour.insert(best_insert_idx, best_node)\n            unvisited_remaining.remove(best_node)\n        else:\n            break # no node could be inserted\n\n    # Force insert nodes with highest prize if still infeasible\n    if not state.is_feasible():\n        unvisited_remaining = sorted(unvisited_remaining, key=lambda node: DATA.prizes[node], reverse=True)\n        while not state.is_feasible() and unvisited_remaining:\n            node = unvisited_remaining.pop(0)\n            best_insert_idx = -1\n            best_insert_cost = float('inf')\n\n            for i in range(len(tour) + 1):\n                temp_tour = list(tour)\n                temp_tour.insert(i, node)\n                \n                tour_cost = 0.0\n                if len(temp_tour) > 0:\n                    start = DATA.depot\n                    for j in range(len(temp_tour)):\n                        end = DATA.locations[temp_tour[j]]\n                        tour_cost += np.linalg.norm(start - end)\n                        start = end\n                    tour_cost += np.linalg.norm(start - DATA.depot)\n\n                current_penalty = sum(DATA.penalties[n] for n in unvisited_remaining if n != node)\n                temp_cost = tour_cost + current_penalty\n                \n                if temp_cost < best_insert_cost:\n                    best_insert_cost = temp_cost\n                    best_insert_idx = i\n\n            if best_insert_idx != -1:\n                tour.insert(best_insert_idx, node)\n\n    # Update the state with the modified tour and unvisited nodes\n    state.tour = tour\n    state.unvisited = [node for node in range(DATA.size) if node not in state.tour]\n\n    return state",
    "objective": 18.064649676006386,
    "gap": -0.7845270481827213,
    "runtime": 69.21449136734009,
    "timestamp": "2025-06-13 16:45:30",
    "feasible": true,
    "instance1_objective": 9.178151126545233,
    "instance2_objective": 8.886498549461153,
    "instance1_gap": -4.1386502923203405,
    "instance2_gap": 2.569596195954898,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 200,
    "prize_collected": 4.136391213436879,
    "strategy": "e2",
    "generation": 1
  }
]