[
  {
    "algorithm": "New PCTSP algorithm inspired by existing approaches but with different logic",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    This operator focuses on penalty-driven insertion and strategic prize collection.\n    \"\"\"\n\n    unvisited_nodes = list(state.unvisited)\n\n    # 1. Penalty-driven node selection: Prioritize nodes with high penalties\n    penalty_priority = {node: DATA.penalties[node] for node in unvisited_nodes}\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: penalty_priority[node], reverse=True)\n\n    # 2. Insert nodes until a certain prize threshold is met, or no more nodes.\n    prize_buffer = 0.9 * DATA.total_prize  # Aim for 90% of the total prize initially\n    \n    while state.total_prize() < prize_buffer and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        state.opt_insert(node)  # Insert at the best possible location\n\n    # 3. Distance-aware insertion for remaining nodes:\n    remaining_unvisited = list(state.unvisited)\n    \n    if remaining_unvisited:\n      distances = {}\n      for node in remaining_unvisited:\n          min_dist = float('inf')\n          if state.tour:\n              for tour_node in state.tour:\n                  dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                  min_dist = min(min_dist, dist)\n              dist_to_depot1 = np.linalg.norm(DATA.locations[node] - DATA.depot)\n              dist_to_depot2 = np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n          else:\n              min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n          distances[node] = min_dist\n      \n      distance_priority = {node: distances[node] for node in remaining_unvisited}\n      distance_sorted_nodes = sorted(remaining_unvisited, key=lambda node: distance_priority[node])\n      \n      for node in distance_sorted_nodes:\n          if state.total_prize() < DATA.total_prize:\n            state.opt_insert(node)\n          else:\n            break # Enough prize\n\n    # 4. Feasibility enforcement: If still infeasible, insert the node with highest prize/penalty ratio\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break # cannot be repaired\n\n        best_node = None\n        best_ratio = -1.0\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / (DATA.penalties[node] + 1e-9) # Avoid division by zero\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break # no more nodes, repair failed\n\n    return state",
    "objective": 14.280693151909972,
    "gap": -21.69376009042803,
    "runtime": 60.027249813079834,
    "timestamp": "2025-06-13 16:48:52",
    "feasible": true,
    "instance1_objective": 7.486696356068971,
    "instance2_objective": 6.793996795841002,
    "instance1_gap": -21.805077335386624,
    "instance2_gap": -21.58244284546943,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 83,
    "prize_collected": 2.0375640371898065,
    "strategy": "e1",
    "generation": 2
  },
  {
    "algorithm": "New PCTSP algorithm inspired by existing approaches but with different logic",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution based on a combination of distance and prize.\n    \"\"\"\n    unvisited_nodes = list(state.unvisited)\n    \n    # Calculate distance to the closest node in the tour for each unvisited node\n    distances = {}\n    for node in unvisited_nodes:\n        min_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                min_dist = min(min_dist, dist)\n            dist_to_depot1 = np.linalg.norm(DATA.locations[node] - DATA.depot)\n            dist_to_depot2 = np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n        else:\n            min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        distances[node] = min_dist\n\n    # Combine prize and distance to prioritize nodes\n    priority = {node: DATA.prizes[node] / (distances[node] + 1e-6) for node in unvisited_nodes}\n\n    # Sort unvisited nodes based on priority\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: priority[node], reverse=True)\n\n    # Insert nodes into the tour until feasible or no more nodes to insert\n    while not state.is_feasible() and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        \n        # Find the best insertion point based on minimizing tour length increase\n        best_idx = -1\n        min_increase = float('inf')\n        \n        if state.tour:\n            for i in range(len(state.tour) + 1):\n                temp_tour = list(state.tour)\n                temp_tour.insert(i, node)\n                \n                tour_length = 0\n                start_node = DATA.depot\n                for j in range(len(temp_tour)):\n                    end_node = DATA.locations[temp_tour[j]]\n                    tour_length += np.linalg.norm(start_node - end_node)\n                    start_node = end_node\n                tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                original_tour_length = 0\n                start_node = DATA.depot\n                for j in range(len(state.tour)):\n                    end_node = DATA.locations[state.tour[j]]\n                    original_tour_length += np.linalg.norm(start_node - end_node)\n                    start_node = end_node\n                original_tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                increase = tour_length - original_tour_length\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_idx = i\n        else:\n                best_idx = 0 #Insert at start\n\n        state.insert(node, best_idx)\n    \n\n    # If still infeasible, add the node with the highest prize to penalty ratio\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break\n            \n        best_node = None\n        best_ratio = -1\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / (DATA.penalties[node] + 1e-6)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break\n            \n    return state",
    "objective": 14.422278216998588,
    "gap": -20.647907669172188,
    "runtime": 60.012267112731934,
    "timestamp": "2025-06-13 16:44:24",
    "feasible": true,
    "instance1_objective": 7.069899610537622,
    "instance2_objective": 7.352378606460966,
    "instance1_gap": -26.1583177679663,
    "instance2_gap": -15.137497570378075,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 52,
    "prize_collected": 2.030564893762092,
    "strategy": "e1",
    "generation": 1
  },
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Combines distance, prize, and penalty considerations for inserting unvisited nodes.\n    \"\"\"\n    unvisited_nodes = list(state.unvisited)\n\n    # Calculate distance to the closest node in the tour for each unvisited node\n    distances = {}\n    for node in unvisited_nodes:\n        min_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                min_dist = min(min_dist, dist)\n        else:\n            min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n        distances[node] = min_dist\n\n    # Combine prize, distance, and penalty to prioritize nodes\n    priority = {node: DATA.prizes[node] / (distances[node] + 1e-6) - DATA.penalties[node] / (DATA.size + 1e-6) for node in unvisited_nodes}\n    \n    # Sort unvisited nodes based on priority\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: priority[node], reverse=True)\n\n    # Insert nodes into the tour until feasible or no more nodes to insert\n    while not state.is_feasible() and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        state.opt_insert(node)  # Use optimal insertion\n\n    # If still infeasible, add the node with the highest prize to penalty ratio greedily\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break  # No more nodes to insert\n\n        # Prioritize inserting nodes with high prize to penalty ratio\n        best_node = max(remaining_unvisited, key=lambda n: DATA.prizes[n] / (DATA.penalties[n] + 1e-6))\n        state.opt_insert(best_node)\n\n    return state",
    "objective": 14.67858491317437,
    "gap": -19.38113996188401,
    "runtime": 60.00393891334534,
    "timestamp": "2025-06-13 16:49:55",
    "feasible": true,
    "instance1_objective": 7.4569053839673884,
    "instance2_objective": 7.221679529206982,
    "instance1_gap": -22.116229631245197,
    "instance2_gap": -16.646050292522826,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 50,
    "prize_collected": 2.026233350050922,
    "strategy": "e2",
    "generation": 2
  },
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Combines penalty-driven and distance/prize-aware insertion with feasibility enforcement.\n    \"\"\"\n\n    unvisited_nodes = list(state.unvisited)\n\n    # 1. Penalty-driven node selection with a prize consideration:\n    penalty_priority = {node: DATA.penalties[node] for node in unvisited_nodes}\n    prize_priority = {node: DATA.prizes[node] for node in unvisited_nodes}\n    combined_priority = {node: penalty_priority[node] + prize_priority[node] for node in unvisited_nodes}\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: combined_priority[node], reverse=True)\n\n    # 2. Insert nodes until a certain prize threshold is met.\n    prize_buffer = 0.9 * DATA.total_prize  # Aim for 90% of the total prize initially\n    \n    while state.total_prize() < prize_buffer and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        state.opt_insert(node)  # Insert at the best possible location\n\n    # 3. Distance and prize-aware insertion for remaining nodes:\n    remaining_unvisited = list(state.unvisited)\n    \n    if remaining_unvisited:\n      distances = {}\n      for node in remaining_unvisited:\n          min_dist = float('inf')\n          if state.tour:\n              for tour_node in state.tour:\n                  dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                  min_dist = min(min_dist, dist)\n              #dist_to_depot1 = np.linalg.norm(DATA.locations[node] - DATA.depot)\n              #dist_to_depot2 = np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n          else:\n              min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n          distances[node] = min_dist\n      \n      # Combine prize and distance to prioritize nodes\n      priority = {node: DATA.prizes[node] / (distances[node] + 1e-6) for node in remaining_unvisited}\n\n      # Sort unvisited nodes based on priority\n      distance_sorted_nodes = sorted(remaining_unvisited, key=lambda node: priority[node], reverse=True)\n\n      \n      for node in distance_sorted_nodes:\n          if state.total_prize() < DATA.total_prize:\n              # Find the best insertion point based on minimizing tour length increase\n              best_idx = -1\n              min_increase = float('inf')\n        \n              if state.tour:\n                  for i in range(len(state.tour) + 1):\n                      temp_tour = list(state.tour)\n                      temp_tour.insert(i, node)\n                \n                      tour_length = 0\n                      start_node = DATA.depot\n                      for j in range(len(temp_tour)):\n                          end_node = DATA.locations[temp_tour[j]]\n                          tour_length += np.linalg.norm(start_node - end_node)\n                          start_node = end_node\n                      tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                      original_tour_length = 0\n                      start_node = DATA.depot\n                      for j in range(len(state.tour)):\n                          end_node = DATA.locations[state.tour[j]]\n                          original_tour_length += np.linalg.norm(start_node - end_node)\n                          start_node = end_node\n                      original_tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                      increase = tour_length - original_tour_length\n\n                      if increase < min_increase:\n                          min_increase = increase\n                          best_idx = i\n              else:\n                  best_idx = 0 #Insert at start\n\n              state.insert(node, best_idx)\n          else:\n            break # Enough prize\n\n    # 4. Feasibility enforcement: If still infeasible, insert the node with highest prize/penalty ratio\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break # cannot be repaired\n\n        best_node = None\n        best_ratio = -1.0\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / (DATA.penalties[node] + 1e-9) # Avoid division by zero\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break # no more nodes, repair failed\n\n    return state",
    "objective": 15.55268617644316,
    "gap": -14.527231554714412,
    "runtime": 60.008891344070435,
    "timestamp": "2025-06-13 16:54:15",
    "feasible": true,
    "instance1_objective": 7.804205863955945,
    "instance2_objective": 7.748480312487215,
    "instance1_gap": -18.488844081933618,
    "instance2_gap": -10.565619027495208,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 50,
    "prize_collected": 2.059687799240696,
    "strategy": "e2",
    "generation": 3
  },
  {
    "algorithm": "Modified version of: New PCTSP algorithm inspired by existing approaches but with different logic",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    This operator uses a combination of prize density and proximity for node insertion,\n    followed by a feasibility enforcement mechanism.\n    \"\"\"\n\n    unvisited_nodes = list(state.unvisited)\n\n    # 1. Node prioritization based on prize density and proximity.\n    node_priorities = {}\n    for node in unvisited_nodes:\n        # Prize Density: Prize per unit penalty\n        prize_density = DATA.prizes[node] / (DATA.penalties[node] + 1e-9)\n\n        # Proximity: Distance to the nearest node in the current tour or depot if tour is empty\n        if state.tour:\n            distances = [np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node]) for tour_node in state.tour]\n            proximity = min(distances)\n        else:\n            proximity = np.linalg.norm(DATA.locations[node] - DATA.depot)\n        \n        # Combine prize density and proximity: Higher priority for higher prize density and closer proximity\n        node_priorities[node] = prize_density / (proximity + 1e-9)\n\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: node_priorities[node], reverse=True)\n\n    # 2. Iteratively insert nodes until a feasible solution is found or all nodes are considered.\n    while not state.is_feasible() and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        state.opt_insert(node)\n\n    # 3. If solution is still infeasible, strategically add nodes with the highest prize/cost ratio\n    # to reach the prize constraint. This considers both prize and insertion cost (distance).\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break\n\n        best_node = None\n        best_ratio = -1.0\n        best_insertion_idx = -1\n        \n        for node in remaining_unvisited:\n            # Evaluate all possible insertion positions and choose the best one\n            best_local_insertion_idx = -1\n            best_local_cost_increase = float('inf')\n            \n            for idx in range(len(state.tour) + 1):\n                temp_tour = list(state.tour)\n                temp_tour.insert(idx, node)\n                \n                cost_increase = 0\n                if len(temp_tour) == 1:\n                    cost_increase = np.linalg.norm(DATA.depot - DATA.locations[node]) + np.linalg.norm(DATA.locations[node] - DATA.depot)\n                else:\n                    if idx == 0:\n                        cost_increase = np.linalg.norm(DATA.depot - DATA.locations[node]) + np.linalg.norm(DATA.locations[node] - DATA.locations[temp_tour[1]]) - np.linalg.norm(DATA.depot - DATA.locations[temp_tour[1]])\n                    elif idx == len(temp_tour) -1:\n                         cost_increase = np.linalg.norm(DATA.locations[temp_tour[-2]] - DATA.locations[node]) + np.linalg.norm(DATA.locations[node] - DATA.depot) - np.linalg.norm(DATA.locations[temp_tour[-2]] - DATA.depot)\n                    else:\n                        cost_increase = np.linalg.norm(DATA.locations[temp_tour[idx-1]] - DATA.locations[node]) + np.linalg.norm(DATA.locations[node] - DATA.locations[temp_tour[idx+1]]) - np.linalg.norm(DATA.locations[temp_tour[idx-1]] - DATA.locations[temp_tour[idx+1]])\n                if cost_increase < best_local_cost_increase:\n                    best_local_cost_increase = cost_increase\n                    best_local_insertion_idx = idx\n\n            # Prioritize nodes that offer the most prize for the least increase in cost\n            ratio = DATA.prizes[node] / (best_local_cost_increase + 1e-9)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n                best_insertion_idx = best_local_insertion_idx\n        \n        if best_node is not None:\n            state.insert(best_node, best_insertion_idx)\n        else:\n            break  # Cannot be repaired\n\n    return state",
    "objective": 15.961742458930797,
    "gap": -12.019870289768393,
    "runtime": 60.00547504425049,
    "timestamp": "2025-06-13 16:55:22",
    "feasible": true,
    "instance1_objective": 7.536984678177892,
    "instance2_objective": 8.424757780752904,
    "instance1_gap": -21.27984013178979,
    "instance2_gap": -2.759900447746998,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 57,
    "prize_collected": 2.009013325831042,
    "strategy": "m1",
    "generation": 3
  }
]