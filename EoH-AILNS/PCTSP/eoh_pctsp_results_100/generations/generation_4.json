[
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n\n    # Node selection based on prize, penalty, and proximity to existing tour\n    def node_priority(node):\n        nearest_neighbor_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                nearest_neighbor_dist = min(nearest_neighbor_dist, dist)\n            nearest_neighbor_dist = min(nearest_neighbor_dist, np.linalg.norm(DATA.locations[node] - DATA.depot))\n        else:\n            nearest_neighbor_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        return (DATA.prizes[node] / (DATA.penalties[node] + 1e-6)) * (1 / (nearest_neighbor_dist + 1e-6))\n\n\n    # Insert nodes until feasible, prioritize based on node_priority\n    while not state.is_feasible() and unvisited:\n        priorities = {node: node_priority(node) for node in unvisited}\n        best_node = max(priorities, key=priorities.get)\n\n        state.opt_insert(best_node)\n        unvisited.remove(best_node)\n    \n    # Limited greedy insertion of remaining unvisited nodes, prioritized by prize/penalty ratio\n    num_insertions = min(len(unvisited), int(DATA.size * 0.1))\n    if unvisited:\n      prize_penalty_ratios = DATA.prizes / DATA.penalties\n      \n      #Using a subset for computational efficiency\n      subset_unvisited = list(rng.choice(unvisited, size = min(len(unvisited), num_insertions), replace = False))\n      subset_unvisited.sort(key = lambda node: prize_penalty_ratios[node], reverse=True)\n      \n      for node in subset_unvisited:\n        best_idx = -1\n        best_objective = state.objective()\n        \n        for i in range(len(state.tour) + 1):\n            temp_tour = state.tour.copy()\n            temp_tour.insert(i, node)\n\n            new_tour_cost = 0.0\n            if len(temp_tour) > 1:\n                for j in range(len(temp_tour)-1):\n                    new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n            elif len(temp_tour) == 1:\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n\n            temp_unvisited = state.unvisited.copy()\n            temp_unvisited.remove(node)\n            new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n\n            new_objective = new_tour_cost + new_penalty_cost\n\n            if new_objective < best_objective:\n                best_objective = new_objective\n                best_idx = i\n                \n        if best_idx != -1:\n          state.insert(node, best_idx)\n          unvisited.remove(node)\n\n    # Removal of nodes based on savings after feasible\n    if state.is_feasible():\n      num_removals = min(len(state.tour), int(DATA.size * 0.05))\n      \n      nodes_to_remove = []\n      \n      for _ in range(num_removals):\n          worst_node = None\n          worst_node_savings = -1e10\n          \n          for node in state.tour:\n            temp_tour = state.tour.copy()\n            temp_tour.remove(node)\n\n            new_tour_cost = 0.0\n            if len(temp_tour) > 1:\n                for j in range(len(temp_tour)-1):\n                    new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n            elif len(temp_tour) == 1:\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n            else:\n                new_tour_cost = 0.0\n            \n            temp_unvisited = state.unvisited.copy()\n            temp_unvisited.append(node)\n            new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n            new_objective = new_tour_cost + new_penalty_cost\n            \n            savings = state.objective() - new_objective\n            if savings > worst_node_savings:\n                worst_node_savings = savings\n                worst_node = node\n          \n          if worst_node is not None:\n            state.remove(worst_node)\n            unvisited.append(worst_node)\n            \n    return state",
    "objective": 6.876497975357058,
    "gap": -28.17830431301894,
    "runtime": 60.047784090042114,
    "timestamp": "2025-06-11 18:01:52",
    "feasible": true,
    "tour_length": 29,
    "prize_collected": 1.006216974428851,
    "strategy": "e2",
    "generation": 3
  },
  {
    "algorithm": "Modified version of: New PCTSP algorithm inspired by existing approaches but with different logic",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n\n    # Node selection based on prize, penalty, and proximity to existing tour\n    def node_priority(node):\n        nearest_neighbor_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                nearest_neighbor_dist = min(nearest_neighbor_dist, dist)\n            nearest_neighbor_dist = min(nearest_neighbor_dist, np.linalg.norm(DATA.locations[node] - DATA.depot))\n        else:\n            nearest_neighbor_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        return (DATA.prizes[node] / (DATA.penalties[node] + 1e-6)) * (1 / (nearest_neighbor_dist + 1e-6))\n\n\n    # Insert nodes until feasible, prioritize based on node_priority\n    while not state.is_feasible() and unvisited:\n        priorities = {node: node_priority(node) for node in unvisited}\n        best_node = max(priorities, key=priorities.get)\n\n        state.opt_insert(best_node)\n        unvisited.remove(best_node)\n\n    # Iteratively refine the solution by re-evaluating unvisited nodes\n    num_refinements = min(len(unvisited), int(DATA.size * 0.2))  # Limit refinements\n    \n    for _ in range(num_refinements):\n        if not unvisited:\n            break\n\n        # Select a random unvisited node\n        node_to_consider = rng.choice(unvisited)\n\n        # Evaluate potential insertion\n        best_idx = -1\n        best_objective = state.objective()\n\n        for i in range(len(state.tour) + 1):\n            temp_tour = state.tour.copy()\n            temp_tour.insert(i, node_to_consider)\n\n            new_tour_cost = 0.0\n            if len(temp_tour) > 1:\n                for j in range(len(temp_tour)-1):\n                    new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n            elif len(temp_tour) == 1:\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n\n            temp_unvisited = state.unvisited.copy()\n            temp_unvisited.remove(node_to_consider)\n            new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n\n            new_objective = new_tour_cost + new_penalty_cost\n            \n            if new_objective < best_objective:\n                best_objective = new_objective\n                best_idx = i\n        \n        #If insertion improves the objective, insert and remove from unvisited\n        if best_idx != -1:\n            state.insert(node_to_consider, best_idx)\n            unvisited.remove(node_to_consider)\n        \n        else:\n            #Consider removing a visited node if it makes the current one worth skipping\n            if state.is_feasible():\n                \n                worst_node = None\n                worst_node_savings = -1e10\n                \n                for node in state.tour:\n                  \n                  temp_tour = state.tour.copy()\n                  temp_tour.remove(node)\n\n                  new_tour_cost = 0.0\n                  if len(temp_tour) > 1:\n                      for j in range(len(temp_tour)-1):\n                          new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                      new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                      new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                  elif len(temp_tour) == 1:\n                      new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n                  \n                  temp_unvisited = state.unvisited.copy()\n                  temp_unvisited.append(node)\n                  new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n                  new_objective = new_tour_cost + new_penalty_cost\n                  \n                  savings = state.objective() - new_objective\n                  if savings > worst_node_savings:\n                      worst_node_savings = savings\n                      worst_node = node\n                if worst_node is not None:\n                  temp_tour = state.tour.copy()\n                  temp_tour_idx = temp_tour.index(worst_node)\n                  state.remove(worst_node)\n                  unvisited.append(worst_node)\n\n    return state",
    "objective": 6.942572878804105,
    "gap": -27.488183902175066,
    "runtime": 60.00416302680969,
    "timestamp": "2025-06-11 17:58:32",
    "feasible": false,
    "tour_length": 30,
    "prize_collected": 0.9921166210406744,
    "strategy": "m1",
    "generation": 2
  },
  {
    "algorithm": "Modified version of: Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n\n    # Node selection based on prize, penalty, and proximity to existing tour\n    def node_priority(node):\n        nearest_neighbor_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                nearest_neighbor_dist = min(nearest_neighbor_dist, dist)\n            nearest_neighbor_dist = min(nearest_neighbor_dist, np.linalg.norm(DATA.locations[node] - DATA.depot))\n        else:\n            nearest_neighbor_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        return (DATA.prizes[node] / (DATA.penalties[node] + 1e-6)) * (1 / (nearest_neighbor_dist + 1e-6))\n\n    # Insert nodes until feasible, prioritize based on node_priority\n    while not state.is_feasible() and unvisited:\n        priorities = {node: node_priority(node) for node in unvisited}\n        best_node = max(priorities, key=priorities.get)\n\n        state.opt_insert(best_node)\n        unvisited.remove(best_node)\n    \n    # Improved greedy insertion with lookahead\n    num_insertions = min(len(unvisited), int(DATA.size * 0.15))\n    if unvisited:\n        prize_penalty_ratios = DATA.prizes / (DATA.penalties + 1e-6)\n        subset_unvisited = list(rng.choice(unvisited, size=min(len(unvisited), num_insertions), replace=False))\n        subset_unvisited.sort(key=lambda node: prize_penalty_ratios[node], reverse=True)\n\n        for node in subset_unvisited:\n            best_idx = -1\n            best_objective = state.objective()\n\n            for i in range(len(state.tour) + 1):\n                temp_tour = state.tour.copy()\n                temp_tour.insert(i, node)\n\n                tour_cost = 0.0\n                if len(temp_tour) > 1:\n                    for j in range(len(temp_tour) - 1):\n                        tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j + 1]])\n                    tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                    tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                elif len(temp_tour) == 1:\n                    tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n\n                temp_unvisited = state.unvisited.copy()\n                temp_unvisited.remove(node)\n                penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n\n                objective = tour_cost + penalty_cost\n\n                if objective < best_objective:\n                    best_objective = objective\n                    best_idx = i\n\n            if best_idx != -1:\n                state.insert(node, best_idx)\n                unvisited.remove(node)\n\n    # Removal based on savings after feasible, consider prize contribution\n    if state.is_feasible():\n        num_removals = min(len(state.tour), int(DATA.size * 0.05))\n\n        for _ in range(num_removals):\n            worst_node = None\n            worst_node_savings = -1e10\n\n            for node in state.tour:\n                temp_tour = state.tour.copy()\n                temp_tour.remove(node)\n\n                tour_cost = 0.0\n                if len(temp_tour) > 1:\n                    for j in range(len(temp_tour) - 1):\n                        tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j + 1]])\n                    tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                    tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                elif len(temp_tour) == 1:\n                    tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n                else:\n                    tour_cost = 0.0\n\n                temp_unvisited = state.unvisited.copy()\n                temp_unvisited.append(node)\n                penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n                objective = tour_cost + penalty_cost\n\n                savings = state.objective() - objective - 0.1 * DATA.prizes[node]  # Prioritize removing low-prize nodes\n                if savings > worst_node_savings:\n                    worst_node_savings = savings\n                    worst_node = node\n\n            if worst_node is not None:\n                state.remove(worst_node)\n                unvisited.append(worst_node)\n    \n    return state",
    "objective": 6.964627835430611,
    "gap": -27.257830546601483,
    "runtime": 60.00568699836731,
    "timestamp": "2025-06-11 18:07:36",
    "feasible": false,
    "tour_length": 27,
    "prize_collected": 0.8431442913573652,
    "strategy": "m1",
    "generation": 4
  },
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n\n    # Prioritize nodes based on a combination of prize and distance to nearest neighbor in the tour\n    def node_priority(node):\n        nearest_neighbor_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                nearest_neighbor_dist = min(nearest_neighbor_dist, dist)\n            nearest_neighbor_dist = min(nearest_neighbor_dist, np.linalg.norm(DATA.locations[node] - DATA.depot))\n        else:\n             nearest_neighbor_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        return DATA.prizes[node] / (nearest_neighbor_dist + 1e-6)  # Add small value to avoid division by zero\n\n\n    # First, insert nodes until feasible, prioritizing by the node_priority\n    while not state.is_feasible() and unvisited:\n        \n        priorities = {node: node_priority(node) for node in unvisited}\n        best_node = max(priorities, key=priorities.get)\n        \n        state.opt_insert(best_node)\n        unvisited.remove(best_node)\n\n    # Now, try to insert the remaining nodes with a greedy insertion strategy, but limit the number\n    # of insertions to avoid excessive computational cost. Also, use a random subset to prevent getting stuck\n    num_insertions = min(len(unvisited), int(DATA.size * 0.1))  # Limit to 10% of nodes or the number of unvisited nodes\n    \n    if unvisited:\n        subset_unvisited = list(rng.choice(unvisited, size=num_insertions, replace=False))\n        \n        # Calculate prize-to-penalty ratio for each node\n        prize_penalty_ratios = DATA.prizes / DATA.penalties\n\n        # Sort unvisited nodes by prize-to-penalty ratio in descending order (using subset)\n        subset_unvisited.sort(key=lambda node: prize_penalty_ratios[node], reverse=True)\n        \n        for node in subset_unvisited:\n            best_idx = -1\n            best_objective = state.objective()\n            \n            for i in range(len(state.tour) + 1):\n                temp_tour = state.tour.copy()\n                temp_tour.insert(i, node)\n                \n                # Calculate objective change if the node is inserted\n                new_tour_cost = 0.0\n                if len(temp_tour) > 1:\n                  for j in range(len(temp_tour)-1):\n                    new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                  new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                  new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                elif len(temp_tour) == 1:\n                  new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n                  \n                temp_unvisited = state.unvisited.copy()\n                temp_unvisited.remove(node)\n                new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n\n                new_objective = new_tour_cost + new_penalty_cost\n\n                if new_objective < best_objective:\n                    best_objective = new_objective\n                    best_idx = i\n            \n            if best_idx != -1:\n                state.insert(node, best_idx)\n                unvisited.remove(node)\n                \n\n    return state",
    "objective": 6.97968893044183,
    "gap": -27.100524693173625,
    "runtime": 60.024811029434204,
    "timestamp": "2025-06-11 17:57:24",
    "feasible": true,
    "tour_length": 26,
    "prize_collected": 1.0179192193899562,
    "strategy": "e2",
    "generation": 2
  },
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n\n    # Node selection based on prize, penalty, and proximity to existing tour\n    def node_priority(node):\n        nearest_neighbor_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                nearest_neighbor_dist = min(nearest_neighbor_dist, dist)\n            nearest_neighbor_dist = min(nearest_neighbor_dist, np.linalg.norm(DATA.locations[node] - DATA.depot))\n        else:\n            nearest_neighbor_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        return (DATA.prizes[node] / (DATA.penalties[node] + 1e-6)) * (1 / (nearest_neighbor_dist + 1e-6))\n\n\n    # Insert nodes until feasible, prioritize based on node_priority\n    while not state.is_feasible() and unvisited:\n        priorities = {node: node_priority(node) for node in unvisited}\n        best_node = max(priorities, key=priorities.get)\n\n        state.opt_insert(best_node)\n        unvisited.remove(best_node)\n\n    # Limited greedy insertion of remaining unvisited nodes, prioritized by prize/penalty ratio\n    num_insertions = min(len(unvisited), int(DATA.size * 0.1))\n    if unvisited:\n        prize_penalty_ratios = DATA.prizes / DATA.penalties\n        \n        #Using a subset for computational efficiency\n        subset_unvisited = list(rng.choice(unvisited, size = min(len(unvisited), num_insertions), replace = False))\n        subset_unvisited.sort(key = lambda node: prize_penalty_ratios[node], reverse=True)\n        \n        for node in subset_unvisited:\n            best_idx = -1\n            best_objective = state.objective()\n            \n            for i in range(len(state.tour) + 1):\n                temp_tour = state.tour.copy()\n                temp_tour.insert(i, node)\n\n                new_tour_cost = 0.0\n                if len(temp_tour) > 1:\n                    for j in range(len(temp_tour)-1):\n                        new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                    new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                    new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                elif len(temp_tour) == 1:\n                    new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n\n                temp_unvisited = state.unvisited.copy()\n                temp_unvisited.remove(node)\n                new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n\n                new_objective = new_tour_cost + new_penalty_cost\n\n                if new_objective < best_objective:\n                    best_objective = new_objective\n                    best_idx = i\n                    \n            if best_idx != -1:\n                state.insert(node, best_idx)\n                unvisited.remove(node)\n\n    # Iteratively refine the solution by re-evaluating unvisited nodes\n    num_refinements = min(len(unvisited), int(DATA.size * 0.05))  # Limit refinements\n    \n    for _ in range(num_refinements):\n        if not unvisited:\n            break\n\n        # Select a random unvisited node\n        node_to_consider = rng.choice(unvisited)\n\n        # Evaluate potential insertion\n        best_idx = -1\n        best_objective = state.objective()\n\n        for i in range(len(state.tour) + 1):\n            temp_tour = state.tour.copy()\n            temp_tour.insert(i, node_to_consider)\n\n            new_tour_cost = 0.0\n            if len(temp_tour) > 1:\n                for j in range(len(temp_tour)-1):\n                    new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n            elif len(temp_tour) == 1:\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n\n            temp_unvisited = state.unvisited.copy()\n            temp_unvisited.remove(node_to_consider)\n            new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n\n            new_objective = new_tour_cost + new_penalty_cost\n            \n            if new_objective < best_objective:\n                best_objective = new_objective\n                best_idx = i\n        \n        #If insertion improves the objective, insert and remove from unvisited\n        if best_idx != -1:\n            state.insert(node_to_consider, best_idx)\n            unvisited.remove(node_to_consider)\n        \n        else:\n            #Consider removing a visited node if it makes the current one worth skipping\n            if state.is_feasible():\n                \n                worst_node = None\n                worst_node_savings = -1e10\n                \n                for node in state.tour:\n                  \n                  temp_tour = state.tour.copy()\n                  temp_tour.remove(node)\n\n                  new_tour_cost = 0.0\n                  if len(temp_tour) > 1:\n                      for j in range(len(temp_tour)-1):\n                          new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                      new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                      new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n                  elif len(temp_tour) == 1:\n                      new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n                  \n                  temp_unvisited = state.unvisited.copy()\n                  temp_unvisited.append(node)\n                  new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n                  new_objective = new_tour_cost + new_penalty_cost\n                  \n                  savings = state.objective() - new_objective\n                  if savings > worst_node_savings:\n                      worst_node_savings = savings\n                      worst_node = node\n                if worst_node is not None:\n                  temp_tour = state.tour.copy()\n                  temp_tour_idx = temp_tour.index(worst_node)\n                  state.remove(worst_node)\n                  unvisited.append(worst_node)\n\n    return state",
    "objective": 7.011826813113062,
    "gap": -26.76486005144626,
    "runtime": 60.02687692642212,
    "timestamp": "2025-06-11 18:06:28",
    "feasible": false,
    "tour_length": 30,
    "prize_collected": 0.9943786165835109,
    "strategy": "e2",
    "generation": 4
  }
]