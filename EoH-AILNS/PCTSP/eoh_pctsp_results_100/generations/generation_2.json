[
  {
    "algorithm": "New PCTSP algorithm inspired by existing approaches but with different logic",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    This operator focuses on penalty-driven insertion and strategic prize collection.\n    \"\"\"\n\n    unvisited_nodes = list(state.unvisited)\n\n    # 1. Penalty-driven node selection: Prioritize nodes with high penalties\n    penalty_priority = {node: DATA.penalties[node] for node in unvisited_nodes}\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: penalty_priority[node], reverse=True)\n\n    # 2. Insert nodes until a certain prize threshold is met, or no more nodes.\n    prize_buffer = 0.9 * DATA.total_prize  # Aim for 90% of the total prize initially\n    \n    while state.total_prize() < prize_buffer and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        state.opt_insert(node)  # Insert at the best possible location\n\n    # 3. Distance-aware insertion for remaining nodes:\n    remaining_unvisited = list(state.unvisited)\n    \n    if remaining_unvisited:\n      distances = {}\n      for node in remaining_unvisited:\n          min_dist = float('inf')\n          if state.tour:\n              for tour_node in state.tour:\n                  dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                  min_dist = min(min_dist, dist)\n              dist_to_depot1 = np.linalg.norm(DATA.locations[node] - DATA.depot)\n              dist_to_depot2 = np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n          else:\n              min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n          distances[node] = min_dist\n      \n      distance_priority = {node: distances[node] for node in remaining_unvisited}\n      distance_sorted_nodes = sorted(remaining_unvisited, key=lambda node: distance_priority[node])\n      \n      for node in distance_sorted_nodes:\n          if state.total_prize() < DATA.total_prize:\n            state.opt_insert(node)\n          else:\n            break # Enough prize\n\n    # 4. Feasibility enforcement: If still infeasible, insert the node with highest prize/penalty ratio\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break # cannot be repaired\n\n        best_node = None\n        best_ratio = -1.0\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / (DATA.penalties[node] + 1e-9) # Avoid division by zero\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break # no more nodes, repair failed\n\n    return state",
    "objective": 14.280693151909972,
    "gap": -21.69376009042803,
    "runtime": 60.027249813079834,
    "timestamp": "2025-06-13 16:48:52",
    "feasible": true,
    "instance1_objective": 7.486696356068971,
    "instance2_objective": 6.793996795841002,
    "instance1_gap": -21.805077335386624,
    "instance2_gap": -21.58244284546943,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 83,
    "prize_collected": 2.0375640371898065,
    "strategy": "e1",
    "generation": 2
  },
  {
    "algorithm": "New PCTSP algorithm inspired by existing approaches but with different logic",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution based on a combination of distance and prize.\n    \"\"\"\n    unvisited_nodes = list(state.unvisited)\n    \n    # Calculate distance to the closest node in the tour for each unvisited node\n    distances = {}\n    for node in unvisited_nodes:\n        min_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                min_dist = min(min_dist, dist)\n            dist_to_depot1 = np.linalg.norm(DATA.locations[node] - DATA.depot)\n            dist_to_depot2 = np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n        else:\n            min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        distances[node] = min_dist\n\n    # Combine prize and distance to prioritize nodes\n    priority = {node: DATA.prizes[node] / (distances[node] + 1e-6) for node in unvisited_nodes}\n\n    # Sort unvisited nodes based on priority\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: priority[node], reverse=True)\n\n    # Insert nodes into the tour until feasible or no more nodes to insert\n    while not state.is_feasible() and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        \n        # Find the best insertion point based on minimizing tour length increase\n        best_idx = -1\n        min_increase = float('inf')\n        \n        if state.tour:\n            for i in range(len(state.tour) + 1):\n                temp_tour = list(state.tour)\n                temp_tour.insert(i, node)\n                \n                tour_length = 0\n                start_node = DATA.depot\n                for j in range(len(temp_tour)):\n                    end_node = DATA.locations[temp_tour[j]]\n                    tour_length += np.linalg.norm(start_node - end_node)\n                    start_node = end_node\n                tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                original_tour_length = 0\n                start_node = DATA.depot\n                for j in range(len(state.tour)):\n                    end_node = DATA.locations[state.tour[j]]\n                    original_tour_length += np.linalg.norm(start_node - end_node)\n                    start_node = end_node\n                original_tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                increase = tour_length - original_tour_length\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_idx = i\n        else:\n                best_idx = 0 #Insert at start\n\n        state.insert(node, best_idx)\n    \n\n    # If still infeasible, add the node with the highest prize to penalty ratio\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break\n            \n        best_node = None\n        best_ratio = -1\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / (DATA.penalties[node] + 1e-6)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break\n            \n    return state",
    "objective": 14.422278216998588,
    "gap": -20.647907669172188,
    "runtime": 60.012267112731934,
    "timestamp": "2025-06-13 16:44:24",
    "feasible": true,
    "instance1_objective": 7.069899610537622,
    "instance2_objective": 7.352378606460966,
    "instance1_gap": -26.1583177679663,
    "instance2_gap": -15.137497570378075,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 52,
    "prize_collected": 2.030564893762092,
    "strategy": "e1",
    "generation": 1
  },
  {
    "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Combines distance, prize, and penalty considerations for inserting unvisited nodes.\n    \"\"\"\n    unvisited_nodes = list(state.unvisited)\n\n    # Calculate distance to the closest node in the tour for each unvisited node\n    distances = {}\n    for node in unvisited_nodes:\n        min_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                min_dist = min(min_dist, dist)\n        else:\n            min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n        distances[node] = min_dist\n\n    # Combine prize, distance, and penalty to prioritize nodes\n    priority = {node: DATA.prizes[node] / (distances[node] + 1e-6) - DATA.penalties[node] / (DATA.size + 1e-6) for node in unvisited_nodes}\n    \n    # Sort unvisited nodes based on priority\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: priority[node], reverse=True)\n\n    # Insert nodes into the tour until feasible or no more nodes to insert\n    while not state.is_feasible() and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        state.opt_insert(node)  # Use optimal insertion\n\n    # If still infeasible, add the node with the highest prize to penalty ratio greedily\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break  # No more nodes to insert\n\n        # Prioritize inserting nodes with high prize to penalty ratio\n        best_node = max(remaining_unvisited, key=lambda n: DATA.prizes[n] / (DATA.penalties[n] + 1e-6))\n        state.opt_insert(best_node)\n\n    return state",
    "objective": 14.67858491317437,
    "gap": -19.38113996188401,
    "runtime": 60.00393891334534,
    "timestamp": "2025-06-13 16:49:55",
    "feasible": true,
    "instance1_objective": 7.4569053839673884,
    "instance2_objective": 7.221679529206982,
    "instance1_gap": -22.116229631245197,
    "instance2_gap": -16.646050292522826,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 50,
    "prize_collected": 2.026233350050922,
    "strategy": "e2",
    "generation": 2
  },
  {
    "algorithm": "Modified version of: New PCTSP algorithm inspired by existing approaches but with different logic",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution based on a combination of distance and prize,\n    with enhanced node selection and insertion strategies.\n    \"\"\"\n    unvisited_nodes = list(state.unvisited)\n\n    # Calculate distance to the closest node in the tour for each unvisited node\n    distances = {}\n    for node in unvisited_nodes:\n        min_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                min_dist = min(min_dist, dist)\n        else:\n            min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        distances[node] = min_dist\n\n    # Combine prize, distance, and penalty to prioritize nodes\n    priority = {\n        node: (DATA.prizes[node] / (DATA.penalties[node] + 1e-6)) * (1 / (distances[node] + 1e-6))\n        for node in unvisited_nodes\n    }\n\n    # Sort unvisited nodes based on priority\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: priority[node], reverse=True)\n\n    # Insert nodes into the tour until feasible or no more nodes to insert\n    while not state.is_feasible() and sorted_nodes:\n        node = sorted_nodes.pop(0)\n\n        # Find the best insertion point based on minimizing tour length increase\n        best_idx = -1\n        min_increase = float('inf')\n\n        if state.tour:\n            for i in range(len(state.tour) + 1):\n                # Calculate the increase in tour length for inserting the node at index i\n                if i == 0:\n                    increase = np.linalg.norm(DATA.depot - DATA.locations[node]) + \\\n                               np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[0]]) - \\\n                               np.linalg.norm(DATA.depot - DATA.locations[state.tour[0]])\n                elif i == len(state.tour):\n                    increase = np.linalg.norm(DATA.locations[state.tour[i - 1]] - DATA.locations[node]) + \\\n                               np.linalg.norm(DATA.locations[node] - DATA.depot) - \\\n                               np.linalg.norm(DATA.locations[state.tour[i - 1]] - DATA.depot)\n                else:\n                    increase = np.linalg.norm(DATA.locations[state.tour[i - 1]] - DATA.locations[node]) + \\\n                               np.linalg.norm(DATA.locations[node] - DATA.locations[state.tour[i]]) - \\\n                               np.linalg.norm(DATA.locations[state.tour[i - 1]] - DATA.locations[state.tour[i]])\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_idx = i\n        else:\n            best_idx = 0  # Insert at start\n\n        state.insert(node, best_idx)\n\n    # If still infeasible, add nodes based on prize/penalty ratio until feasible\n    remaining_unvisited = list(state.unvisited)\n    while not state.is_feasible() and remaining_unvisited:\n        best_node = None\n        best_ratio = -1\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / (DATA.penalties[node] + 1e-6)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n            remaining_unvisited.remove(best_node)\n        else:\n            break\n\n    return state",
    "objective": 16.248586535677617,
    "gap": -10.345896676607449,
    "runtime": 60.00484490394592,
    "timestamp": "2025-06-13 16:51:01",
    "feasible": true,
    "instance1_objective": 7.503149026017766,
    "instance2_objective": 8.745437509659851,
    "instance1_gap": -21.63323715474011,
    "instance2_gap": 0.9414438015252123,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 61,
    "prize_collected": 2.060827030905365,
    "strategy": "m1",
    "generation": 2
  },
  {
    "algorithm": "Simplified version of: Initial PCTSP repair operator generated from scratch",
    "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Aims for simplicity and robustness.\n    \"\"\"\n\n    unvisited_nodes = list(state.unvisited)\n    rng.shuffle(unvisited_nodes)\n\n    for node in unvisited_nodes:\n        state.opt_insert(node)\n\n    # If the solution is still infeasible, greedily insert nodes until it becomes feasible\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            # No more nodes to insert, repair failed.\n            break\n\n        # Prioritize inserting nodes with high prize\n        best_node = max(remaining_unvisited, key=lambda n: DATA.prizes[n])\n        state.opt_insert(best_node)\n\n    return state",
    "objective": 17.24255803594884,
    "gap": -5.353874591537096,
    "runtime": 60.17847967147827,
    "timestamp": "2025-06-13 16:47:46",
    "feasible": true,
    "instance1_objective": 8.859258972267789,
    "instance2_objective": 8.38329906368105,
    "instance1_gap": -7.46932461863557,
    "instance2_gap": -3.238424564438623,
    "instance1_feasible": true,
    "instance2_feasible": true,
    "tour_length": 200,
    "prize_collected": 4.1363912134368785,
    "strategy": "m3",
    "generation": 1
  }
]