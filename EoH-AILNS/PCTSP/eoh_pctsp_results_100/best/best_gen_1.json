{
  "algorithm": "New PCTSP algorithm inspired by existing approaches but with different logic",
  "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    Inserts unvisited nodes back into the solution based on a combination of distance and prize.\n    \"\"\"\n    unvisited_nodes = list(state.unvisited)\n    \n    # Calculate distance to the closest node in the tour for each unvisited node\n    distances = {}\n    for node in unvisited_nodes:\n        min_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                min_dist = min(min_dist, dist)\n            dist_to_depot1 = np.linalg.norm(DATA.locations[node] - DATA.depot)\n            dist_to_depot2 = np.linalg.norm(DATA.locations[state.tour[0]] - DATA.depot)\n\n        else:\n            min_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        distances[node] = min_dist\n\n    # Combine prize and distance to prioritize nodes\n    priority = {node: DATA.prizes[node] / (distances[node] + 1e-6) for node in unvisited_nodes}\n\n    # Sort unvisited nodes based on priority\n    sorted_nodes = sorted(unvisited_nodes, key=lambda node: priority[node], reverse=True)\n\n    # Insert nodes into the tour until feasible or no more nodes to insert\n    while not state.is_feasible() and sorted_nodes:\n        node = sorted_nodes.pop(0)\n        \n        # Find the best insertion point based on minimizing tour length increase\n        best_idx = -1\n        min_increase = float('inf')\n        \n        if state.tour:\n            for i in range(len(state.tour) + 1):\n                temp_tour = list(state.tour)\n                temp_tour.insert(i, node)\n                \n                tour_length = 0\n                start_node = DATA.depot\n                for j in range(len(temp_tour)):\n                    end_node = DATA.locations[temp_tour[j]]\n                    tour_length += np.linalg.norm(start_node - end_node)\n                    start_node = end_node\n                tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                original_tour_length = 0\n                start_node = DATA.depot\n                for j in range(len(state.tour)):\n                    end_node = DATA.locations[state.tour[j]]\n                    original_tour_length += np.linalg.norm(start_node - end_node)\n                    start_node = end_node\n                original_tour_length += np.linalg.norm(start_node - DATA.depot)\n                \n                increase = tour_length - original_tour_length\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_idx = i\n        else:\n                best_idx = 0 #Insert at start\n\n        state.insert(node, best_idx)\n    \n\n    # If still infeasible, add the node with the highest prize to penalty ratio\n    while not state.is_feasible():\n        remaining_unvisited = list(state.unvisited)\n        if not remaining_unvisited:\n            break\n            \n        best_node = None\n        best_ratio = -1\n        for node in remaining_unvisited:\n            ratio = DATA.prizes[node] / (DATA.penalties[node] + 1e-6)\n            if ratio > best_ratio:\n                best_ratio = ratio\n                best_node = node\n\n        if best_node is not None:\n            state.opt_insert(best_node)\n        else:\n            break\n            \n    return state",
  "objective": 14.422278216998588,
  "gap": -20.647907669172188,
  "runtime": 60.012267112731934,
  "timestamp": "2025-06-13 16:44:24",
  "feasible": true,
  "instance1_objective": 7.069899610537622,
  "instance2_objective": 7.352378606460966,
  "instance1_gap": -26.1583177679663,
  "instance2_gap": -15.137497570378075,
  "instance1_feasible": true,
  "instance2_feasible": true,
  "tour_length": 52,
  "prize_collected": 2.030564893762092,
  "strategy": "e1",
  "generation": 1
}