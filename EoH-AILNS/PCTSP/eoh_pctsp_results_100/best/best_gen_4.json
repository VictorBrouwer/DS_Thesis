{
  "algorithm": "Hybrid PCTSP algorithm combining ideas from parent operators",
  "code": "def llm_repair(state: 'PCTSPSolution', rng, **kwargs) -> 'PCTSPSolution':\n    \"\"\"\n    Repair operator for the Price Collecting Travelling Salesman Problem (PCTSP) using ALNS.\n    \"\"\"\n\n    unvisited = state.unvisited.copy()\n\n    # Node selection based on prize, penalty, and proximity to existing tour\n    def node_priority(node):\n        nearest_neighbor_dist = float('inf')\n        if state.tour:\n            for tour_node in state.tour:\n                dist = np.linalg.norm(DATA.locations[node] - DATA.locations[tour_node])\n                nearest_neighbor_dist = min(nearest_neighbor_dist, dist)\n            nearest_neighbor_dist = min(nearest_neighbor_dist, np.linalg.norm(DATA.locations[node] - DATA.depot))\n        else:\n            nearest_neighbor_dist = np.linalg.norm(DATA.locations[node] - DATA.depot)\n\n        return (DATA.prizes[node] / (DATA.penalties[node] + 1e-6)) * (1 / (nearest_neighbor_dist + 1e-6))\n\n\n    # Insert nodes until feasible, prioritize based on node_priority\n    while not state.is_feasible() and unvisited:\n        priorities = {node: node_priority(node) for node in unvisited}\n        best_node = max(priorities, key=priorities.get)\n\n        state.opt_insert(best_node)\n        unvisited.remove(best_node)\n    \n    # Limited greedy insertion of remaining unvisited nodes, prioritized by prize/penalty ratio\n    num_insertions = min(len(unvisited), int(DATA.size * 0.1))\n    if unvisited:\n      prize_penalty_ratios = DATA.prizes / DATA.penalties\n      \n      #Using a subset for computational efficiency\n      subset_unvisited = list(rng.choice(unvisited, size = min(len(unvisited), num_insertions), replace = False))\n      subset_unvisited.sort(key = lambda node: prize_penalty_ratios[node], reverse=True)\n      \n      for node in subset_unvisited:\n        best_idx = -1\n        best_objective = state.objective()\n        \n        for i in range(len(state.tour) + 1):\n            temp_tour = state.tour.copy()\n            temp_tour.insert(i, node)\n\n            new_tour_cost = 0.0\n            if len(temp_tour) > 1:\n                for j in range(len(temp_tour)-1):\n                    new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n            elif len(temp_tour) == 1:\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n\n            temp_unvisited = state.unvisited.copy()\n            temp_unvisited.remove(node)\n            new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n\n            new_objective = new_tour_cost + new_penalty_cost\n\n            if new_objective < best_objective:\n                best_objective = new_objective\n                best_idx = i\n                \n        if best_idx != -1:\n          state.insert(node, best_idx)\n          unvisited.remove(node)\n\n    # Removal of nodes based on savings after feasible\n    if state.is_feasible():\n      num_removals = min(len(state.tour), int(DATA.size * 0.05))\n      \n      nodes_to_remove = []\n      \n      for _ in range(num_removals):\n          worst_node = None\n          worst_node_savings = -1e10\n          \n          for node in state.tour:\n            temp_tour = state.tour.copy()\n            temp_tour.remove(node)\n\n            new_tour_cost = 0.0\n            if len(temp_tour) > 1:\n                for j in range(len(temp_tour)-1):\n                    new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[j]] - DATA.locations[temp_tour[j+1]])\n                new_tour_cost += np.linalg.norm(DATA.locations[temp_tour[-1]] - DATA.depot)\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]])\n            elif len(temp_tour) == 1:\n                new_tour_cost += np.linalg.norm(DATA.depot - DATA.locations[temp_tour[0]]) * 2\n            else:\n                new_tour_cost = 0.0\n            \n            temp_unvisited = state.unvisited.copy()\n            temp_unvisited.append(node)\n            new_penalty_cost = sum(DATA.penalties[n] for n in temp_unvisited)\n            new_objective = new_tour_cost + new_penalty_cost\n            \n            savings = state.objective() - new_objective\n            if savings > worst_node_savings:\n                worst_node_savings = savings\n                worst_node = node\n          \n          if worst_node is not None:\n            state.remove(worst_node)\n            unvisited.append(worst_node)\n            \n    return state",
  "objective": 6.876497975357058,
  "gap": -28.17830431301894,
  "runtime": 60.047784090042114,
  "timestamp": "2025-06-11 18:01:52",
  "feasible": true,
  "tour_length": 29,
  "prize_collected": 1.006216974428851,
  "strategy": "e2",
  "generation": 3
}