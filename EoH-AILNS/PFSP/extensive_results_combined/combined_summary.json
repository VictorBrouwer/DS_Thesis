{
  "timestamp": "2025-06-06 19:10:18",
  "total_runtime_minutes": 9.310055967171987,
  "total_operators": 15,
  "best_overall": {
    "problem": "small",
    "gap": 0.2528445006321112,
    "objective": 1586
  },
  "results_by_problem": [
    {
      "problem_name": "small",
      "problem_description": "Small Problems (20\u00d710)",
      "data_file": "data/j20_m10/j20_m10_01.txt",
      "output_dir": "extensive_results_small",
      "runtime_minutes": 0.3474309841791789,
      "best_gap": 0.2528445006321112,
      "best_objective": 1586,
      "final_population": [
        {
          "algorithm": "Modified version of: Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts unassigned jobs back into the solution to minimize makespan.\n    \"\"\"\n\n    jobs_to_insert = state.unassigned[:]  # Create a copy to avoid modifying original\n    \n    # Shuffle the jobs to insert to avoid bias from the order they were removed\n    rng.shuffle(jobs_to_insert)\n\n    # Iteratively insert the jobs, considering multiple insertion points\n    for job in jobs_to_insert:\n        best_idx = -1\n        best_makespan = float('inf')\n\n        # Try inserting the job at different positions\n        for idx in range(len(state.schedule) + 1):\n            temp_schedule = state.schedule[:]\n            temp_schedule.insert(idx, job)\n            makespan = compute_makespan(temp_schedule)\n\n            if makespan < best_makespan:\n                best_makespan = makespan\n                best_idx = idx\n\n        # Insert the job at the best position found\n        state.insert(job, best_idx)\n\n    state.unassigned = []  # Clear unassigned jobs after insertion\n    \n    return state",
          "objective": 1586,
          "gap": 0.2528445006321112,
          "runtime": 2.4847049713134766,
          "timestamp": "2025-06-06 19:01:16",
          "feasible": true,
          "strategy": "m1",
          "generation": 1
        },
        {
          "algorithm": "Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts unassigned jobs back into the solution to minimize makespan.\n    \"\"\"\n\n    jobs_to_insert = state.unassigned[:]  # Create a copy to avoid modifying original\n    \n    for job in jobs_to_insert:\n        state.opt_insert(job)  # Optimally insert each unassigned job\n        \n    state.unassigned = []  # Clear unassigned jobs after insertion\n    \n    return state",
          "objective": 1593,
          "gap": 0.695322376738306,
          "runtime": 0.6116490364074707,
          "timestamp": "2025-06-06 19:01:07",
          "feasible": true
        },
        {
          "algorithm": "Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state, rng, **kwargs):\n    \"\"\"\n    Repairs the solution by re-inserting unassigned jobs in a smart way,\n    attempting to minimize makespan.\n\n    Args:\n        state: The current solution (Solution object).\n        rng: A numpy.random.Generator object for random operations.\n        **kwargs: Additional keyword arguments (unused).\n\n    Returns:\n        The repaired solution (Solution object).\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]  # Create a copy to iterate over\n\n    # Option 1: Greedy insertion (insert each job at its best position)\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n\n    state.unassigned = []\n\n    return state",
          "objective": 1593,
          "gap": 0.695322376738306,
          "runtime": 0.5967490673065186,
          "timestamp": "2025-06-06 19:01:09",
          "feasible": true
        },
        {
          "algorithm": "Hybrid algorithm combining ideas from parent operators",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts unassigned jobs back into the solution to minimize makespan.\n    \"\"\"\n\n    jobs_to_insert = state.unassigned[:]  # Create a copy to avoid modifying original\n    \n    # Option 1: Greedy insertion (insert each job at its best position)\n    for job in jobs_to_insert:\n        state.opt_insert(job)\n        \n    state.unassigned = []  # Clear unassigned jobs after insertion\n    \n    return state",
          "objective": 1593,
          "gap": 0.695322376738306,
          "runtime": 0.5936770439147949,
          "timestamp": "2025-06-06 19:01:13",
          "feasible": true,
          "strategy": "e2",
          "generation": 1
        },
        {
          "algorithm": "Simplified version of: Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts unassigned jobs back into the solution to minimize makespan.\n    \"\"\"\n\n    for job in state.unassigned[:]:\n        state.opt_insert(job)\n        state.unassigned.remove(job)\n\n    return state",
          "objective": 1593,
          "gap": 0.695322376738306,
          "runtime": 0.6081681251525879,
          "timestamp": "2025-06-06 19:01:19",
          "feasible": true,
          "strategy": "m3",
          "generation": 1
        }
      ]
    },
    {
      "problem_name": "medium",
      "problem_description": "Medium Problems (50\u00d720)",
      "data_file": "data/j50_m20/j50_m20_01.txt",
      "output_dir": "extensive_results_medium",
      "runtime_minutes": 6.504695129394531,
      "best_gap": 1.5483870967741935,
      "best_objective": 3935,
      "final_population": [
        {
          "algorithm": "Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts unassigned jobs back into the solution in a smart way to minimize the makespan.\n\n    Args:\n        state (Solution): The current solution.\n        rng: numpy.random.Generator object for random operations.\n\n    Returns:\n        Solution: The modified solution.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)  # Shuffle the unassigned jobs\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)  # Optimally insert each job\n        \n    state.unassigned = []\n\n    return state",
          "objective": 3935,
          "gap": 1.5483870967741935,
          "runtime": 3.0092742443084717,
          "timestamp": "2025-06-06 19:01:21",
          "feasible": true
        },
        {
          "algorithm": "Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state: 'Solution', rng, **kwargs) -> 'Solution':\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts the unassigned jobs back into the solution in a smart way,\n    trying to minimize the makespan.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)  # Shuffle unassigned jobs for some randomness\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n        \n    state.unassigned = []\n    return state",
          "objective": 3935,
          "gap": 1.5483870967741935,
          "runtime": 2.9964520931243896,
          "timestamp": "2025-06-06 19:01:32",
          "feasible": true
        },
        {
          "algorithm": "Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Args:\n        state (Solution): The current solution.\n        rng: numpy.random.Generator object for random number generation.\n\n    Returns:\n        Solution: The modified solution.\n    \"\"\"\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n    state.unassigned = []\n    return state",
          "objective": 3935,
          "gap": 1.5483870967741935,
          "runtime": 2.9856131076812744,
          "timestamp": "2025-06-06 19:01:53",
          "feasible": true
        },
        {
          "algorithm": "Hybrid algorithm combining ideas from parent operators",
          "code": "def llm_repair(state: 'Solution', rng, **kwargs) -> 'Solution':\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts the unassigned jobs back into the solution in a smart way,\n    trying to minimize the makespan.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)  # Shuffle unassigned jobs for some randomness\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n        \n    state.unassigned = []\n    return state",
          "objective": 3935,
          "gap": 1.5483870967741935,
          "runtime": 2.9460649490356445,
          "timestamp": "2025-06-06 19:02:29",
          "feasible": true,
          "strategy": "e2",
          "generation": 1
        },
        {
          "algorithm": "Hybrid algorithm combining ideas from parent operators",
          "code": "def llm_repair(state: 'Solution', rng, **kwargs) -> 'Solution':\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts the unassigned jobs back into the solution in a smart way,\n    trying to minimize the makespan.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)  # Shuffle unassigned jobs for some randomness\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n        \n    state.unassigned = []\n    return state",
          "objective": 3935,
          "gap": 1.5483870967741935,
          "runtime": 3.09126615524292,
          "timestamp": "2025-06-06 19:02:53",
          "feasible": true,
          "strategy": "e2",
          "generation": 2
        }
      ]
    },
    {
      "problem_name": "large",
      "problem_description": "Large Problems (100\u00d710)",
      "data_file": "data/j100_m10/j100_m10_01.txt",
      "output_dir": "extensive_results_large",
      "runtime_minutes": 2.457929853598277,
      "best_gap": 0.5892547660311959,
      "best_objective": 5804,
      "final_population": [
        {
          "algorithm": "Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    unassigned_jobs = state.unassigned[:]  # Create a copy to avoid modifying original\n    rng.shuffle(unassigned_jobs) #Randomize the order\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n    state.unassigned = []\n    return state",
          "objective": 5804,
          "gap": 0.5892547660311959,
          "runtime": 3.0580508708953857,
          "timestamp": "2025-06-06 19:08:50",
          "feasible": true
        },
        {
          "algorithm": "Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Args:\n        state: The current solution.\n        rng: A numpy.random.Generator object for random operations.\n\n    Returns:\n        The modified solution with unassigned jobs re-inserted.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n\n    state.unassigned = []  # Ensure unassigned list is empty\n\n    return state",
          "objective": 5804,
          "gap": 0.5892547660311959,
          "runtime": 3.047635793685913,
          "timestamp": "2025-06-06 19:09:07",
          "feasible": true
        },
        {
          "algorithm": "Hybrid algorithm combining ideas from parent operators",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Args:\n        state: The current solution.\n        rng: A numpy.random.Generator object for random operations.\n\n    Returns:\n        The modified solution with unassigned jobs re-inserted.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]  # Create a copy\n    rng.shuffle(unassigned_jobs)\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n\n    state.unassigned = []  # Ensure unassigned list is empty\n\n    return state",
          "objective": 5804,
          "gap": 0.5892547660311959,
          "runtime": 3.0377650260925293,
          "timestamp": "2025-06-06 19:10:07",
          "feasible": true,
          "strategy": "e2",
          "generation": 1
        },
        {
          "algorithm": "New algorithm inspired by existing approaches but with different logic",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    This operator inserts unassigned jobs back into the schedule based on a\n    greedy approach considering the increase in makespan at each possible\n    insertion point. It evaluates multiple insertions and chooses the best.\n\n    Args:\n        state: The current solution.\n        rng: A numpy.random.Generator object for random operations.\n\n    Returns:\n        The modified solution with unassigned jobs re-inserted.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]  # Copy to avoid modifying original\n    state.unassigned = []  # Reset unassigned list\n\n    for job in unassigned_jobs:\n        best_insert_idx = -1\n        min_makespan_increase = float('inf')\n        original_makespan = state.objective()\n\n        for i in range(len(state.schedule) + 1):\n            temp_schedule = state.schedule[:]\n            temp_schedule.insert(i, job)\n\n            makespan = compute_makespan(temp_schedule)\n            makespan_increase = makespan - original_makespan\n\n            if makespan_increase < min_makespan_increase:\n                min_makespan_increase = makespan_increase\n                best_insert_idx = i\n\n        state.insert(job, best_insert_idx)\n\n    return state",
          "objective": 5812,
          "gap": 0.7279029462738301,
          "runtime": 52.692911863327026,
          "timestamp": "2025-06-06 19:09:12",
          "feasible": true,
          "strategy": "e1",
          "generation": 1
        },
        {
          "algorithm": "Initial PFSP repair operator generated from scratch",
          "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts the unassigned jobs back into the solution in a smart way,\n    trying to minimize the makespan.\n\n    Args:\n        state: The current solution.\n        rng: A numpy.random.Generator object for random operations.\n        kwargs: Additional keyword arguments.\n\n    Returns:\n        The modified solution.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]  # Create a copy to avoid modifying the original\n\n    # Iterate through the unassigned jobs and optimally insert each one\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n\n    # Clear the unassigned list in the state\n    state.unassigned = []\n\n    return state",
          "objective": 5815,
          "gap": 0.779896013864818,
          "runtime": 2.8005690574645996,
          "timestamp": "2025-06-06 19:08:55",
          "feasible": true
        }
      ]
    }
  ],
  "output_directories": [
    "extensive_results_small",
    "extensive_results_medium",
    "extensive_results_large"
  ]
}