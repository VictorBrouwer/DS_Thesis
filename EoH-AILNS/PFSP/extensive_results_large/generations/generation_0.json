{
  "generation": 0,
  "timestamp": "2025-06-06 19:09:10",
  "problem_file": "data/j100_m10/j100_m10_01.txt",
  "best_known_value": 5770,
  "population_size": 5,
  "population": [
    {
      "algorithm": "Initial PFSP repair operator generated from scratch",
      "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    unassigned_jobs = state.unassigned[:]  # Create a copy to avoid modifying original\n    rng.shuffle(unassigned_jobs) #Randomize the order\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n    state.unassigned = []\n    return state",
      "objective": 5804,
      "gap": 0.5892547660311959,
      "runtime": 3.0580508708953857,
      "timestamp": "2025-06-06 19:08:50",
      "feasible": true
    },
    {
      "algorithm": "Initial PFSP repair operator generated from scratch",
      "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Args:\n        state: The current solution.\n        rng: A numpy.random.Generator object for random operations.\n\n    Returns:\n        The modified solution with unassigned jobs re-inserted.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n\n    state.unassigned = []  # Ensure unassigned list is empty\n\n    return state",
      "objective": 5804,
      "gap": 0.5892547660311959,
      "runtime": 3.047635793685913,
      "timestamp": "2025-06-06 19:09:07",
      "feasible": true
    },
    {
      "algorithm": "Initial PFSP repair operator generated from scratch",
      "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts the unassigned jobs back into the solution in a smart way,\n    trying to minimize the makespan.\n\n    Args:\n        state: The current solution.\n        rng: A numpy.random.Generator object for random operations.\n        kwargs: Additional keyword arguments.\n\n    Returns:\n        The modified solution.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]  # Create a copy to avoid modifying the original\n\n    # Iterate through the unassigned jobs and optimally insert each one\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n\n    # Clear the unassigned list in the state\n    state.unassigned = []\n\n    return state",
      "objective": 5815,
      "gap": 0.779896013864818,
      "runtime": 2.8005690574645996,
      "timestamp": "2025-06-06 19:08:55",
      "feasible": true
    },
    {
      "algorithm": "Initial PFSP repair operator generated from scratch",
      "code": "def llm_repair(state, rng, **kwargs):\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts the unassigned jobs back into the solution in a smart way, trying to minimize the makespan.\n\n    Args:\n        state: The current solution.\n        rng: A numpy.random.Generator object for random number generation.\n\n    Returns:\n        The modified solution.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)  # Randomize the order of insertion\n\n    for job in unassigned_jobs:\n        best_objective = float('inf')\n        best_index = -1\n\n        for i in range(len(state.schedule) + 1):\n            temp_schedule = state.schedule[:]\n            temp_schedule.insert(i, job)\n            makespan = compute_makespan(temp_schedule)\n\n            if makespan < best_objective:\n                best_objective = makespan\n                best_index = i\n\n        state.insert(job, best_index)\n\n    state.unassigned = [] # Clear the unassigned jobs list\n\n\n    return state",
      "objective": 5827,
      "gap": 0.9878682842287695,
      "runtime": 52.974263191223145,
      "timestamp": "2025-06-06 19:07:54",
      "feasible": true
    },
    {
      "algorithm": "Initial PFSP repair operator generated from scratch",
      "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts the unassigned jobs back into the solution in a smart way, trying to minimize the makespan.\n\n    Args:\n        state (Solution): The current solution.\n        rng: numpy.random.Generator object for random operations.\n\n    Returns:\n        Solution: The modified solution.\n    \"\"\"\n    \n    unassigned_jobs = state.unassigned[:]  # Copy the list to avoid modifying the original\n    \n    while unassigned_jobs:\n        job = unassigned_jobs.pop(rng.integers(0, len(unassigned_jobs))) # select a random unassigned job\n        state.opt_insert(job)\n\n    state.unassigned = []\n\n    return state",
      "objective": 5852,
      "gap": 1.4211438474870017,
      "runtime": 2.7961068153381348,
      "timestamp": "2025-06-06 19:09:02",
      "feasible": true
    }
  ]
}