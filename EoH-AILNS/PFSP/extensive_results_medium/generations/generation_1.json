{
  "generation": 1,
  "timestamp": "2025-06-06 19:02:46",
  "problem_file": "data/j50_m20/j50_m20_01.txt",
  "best_known_value": 3875,
  "population_size": 5,
  "population": [
    {
      "algorithm": "Initial PFSP repair operator generated from scratch",
      "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts unassigned jobs back into the solution in a smart way to minimize the makespan.\n\n    Args:\n        state (Solution): The current solution.\n        rng: numpy.random.Generator object for random operations.\n\n    Returns:\n        Solution: The modified solution.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)  # Shuffle the unassigned jobs\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)  # Optimally insert each job\n        \n    state.unassigned = []\n\n    return state",
      "objective": 3935,
      "gap": 1.5483870967741935,
      "runtime": 3.0092742443084717,
      "timestamp": "2025-06-06 19:01:21",
      "feasible": true
    },
    {
      "algorithm": "Initial PFSP repair operator generated from scratch",
      "code": "def llm_repair(state: 'Solution', rng, **kwargs) -> 'Solution':\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts the unassigned jobs back into the solution in a smart way,\n    trying to minimize the makespan.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)  # Shuffle unassigned jobs for some randomness\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n        \n    state.unassigned = []\n    return state",
      "objective": 3935,
      "gap": 1.5483870967741935,
      "runtime": 2.9964520931243896,
      "timestamp": "2025-06-06 19:01:32",
      "feasible": true
    },
    {
      "algorithm": "Initial PFSP repair operator generated from scratch",
      "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Args:\n        state (Solution): The current solution.\n        rng: numpy.random.Generator object for random number generation.\n\n    Returns:\n        Solution: The modified solution.\n    \"\"\"\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n    state.unassigned = []\n    return state",
      "objective": 3935,
      "gap": 1.5483870967741935,
      "runtime": 2.9856131076812744,
      "timestamp": "2025-06-06 19:01:53",
      "feasible": true
    },
    {
      "algorithm": "Hybrid algorithm combining ideas from parent operators",
      "code": "def llm_repair(state: 'Solution', rng, **kwargs) -> 'Solution':\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts the unassigned jobs back into the solution in a smart way,\n    trying to minimize the makespan.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    rng.shuffle(unassigned_jobs)  # Shuffle unassigned jobs for some randomness\n\n    for job in unassigned_jobs:\n        state.opt_insert(job)\n        \n    state.unassigned = []\n    return state",
      "objective": 3935,
      "gap": 1.5483870967741935,
      "runtime": 2.9460649490356445,
      "timestamp": "2025-06-06 19:02:29",
      "feasible": true,
      "strategy": "e2",
      "generation": 1
    },
    {
      "algorithm": "Modified version of: Initial PFSP repair operator generated from scratch",
      "code": "def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Inserts unassigned jobs back into the solution in a smart way to minimize the makespan.\n\n    Args:\n        state (Solution): The current solution.\n        rng: numpy.random.Generator object for random operations.\n\n    Returns:\n        Solution: The modified solution.\n    \"\"\"\n\n    unassigned_jobs = state.unassigned[:]\n    \n    #Prioritize insertion based on processing time on the bottleneck machine\n    bottleneck_machine = np.argmax(np.sum(DATA.processing_times, axis=1))\n    unassigned_jobs.sort(key=lambda job: DATA.processing_times[bottleneck_machine, job], reverse=True)\n    \n    for job in unassigned_jobs:\n        state.opt_insert(job)\n        \n    state.unassigned = []\n    \n    # Local search - try swapping adjacent jobs to improve makespan.\n    for _ in range(min(10, len(state.schedule) // 2)): # Limit swaps based on schedule size\n      idx1 = rng.integers(0, len(state.schedule) - 1)\n      idx2 = idx1 + 1\n      \n      job1 = state.schedule[idx1]\n      job2 = state.schedule[idx2]\n\n      original_makespan = state.objective()\n      \n      #Swap jobs\n      state.schedule[idx1], state.schedule[idx2] = state.schedule[idx2], state.schedule[idx1]\n      \n      new_makespan = compute_makespan(state.schedule) #Recalculate makespan\n      \n      if new_makespan > original_makespan:\n        # Revert swap if it worsened the solution\n        state.schedule[idx1], state.schedule[idx2] = job1, job2\n\n    return state",
      "objective": 3969,
      "gap": 2.425806451612903,
      "runtime": 6.900228023529053,
      "timestamp": "2025-06-06 19:02:35",
      "feasible": true,
      "strategy": "m1",
      "generation": 1
    }
  ]
}