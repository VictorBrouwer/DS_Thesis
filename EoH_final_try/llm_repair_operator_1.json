{
  "prompt": "\n    Generate a repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n    \n    The function signature should be:\n    \n    def llm_repair(state: Solution, rng, **kwargs) -> Solution:\n        # Your implementation here\n        return state\n    \n    You can use the global DATA object that has the following structure:\n    - DATA.n_jobs: number of jobs\n    - DATA.n_machines: number of machines\n    - DATA.processing_times: numpy array of processing times [machine, job]\n    \n    The Solution class has:\n    - schedule: list of jobs (integers)\n    - unassigned: list of jobs that need to be inserted back\n    - objective(): returns the makespan\n    - insert(job, idx): inserts job at index idx\n    - opt_insert(job): optimally inserts job at best position\n    - remove(job): removes job from schedule\n    \n    You can also use these global functions:\n    - compute_makespan(schedule): calculates the makespan of a schedule\n    \n    Important: Use the provided 'rng' parameter for any random operations, NOT the random module.\n    The 'rng' parameter is a numpy.random.Generator object, so use methods like rng.choice() or rng.shuffle().\n    \n    Your operator should:\n    1. Insert the unassigned jobs back into the solution in a smart way\n    2. Try to minimize the makespan\n    3. Be different from the greedy_repair and greedy_repair_then_local_search operators\n    4. Return the modified solution\n    \n    Only provide the function code, no explanations.\n    ",
  "raw_response": "```python\nimport numpy as np\n\ndef llm_repair(state: 'Solution', rng, **kwargs) -> 'Solution':\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Args:\n        state (Solution): The current solution.\n        rng: numpy.random.Generator object for random number generation.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Solution: The repaired solution.\n    \"\"\"\n\n    # First, attempt to insert unassigned jobs using a regret-based heuristic.\n    unassigned = state.unassigned[:]\n    rng.shuffle(unassigned)  # Shuffle to introduce randomness\n\n    while unassigned:\n        job = unassigned.pop()\n        best_idx = -1\n        best_makespan = float('inf')\n        regret = -float('inf')\n\n        for idx in range(len(state.schedule) + 1):\n            temp_schedule = state.schedule[:]\n            temp_schedule.insert(idx, job)\n            makespan = compute_makespan(temp_schedule)\n\n            # Calculate regret value\n            second_best_makespan = float('inf')\n            for other_idx in range(len(state.schedule) + 2):\n                if other_idx == idx:\n                    continue\n                temp_schedule2 = state.schedule[:]\n                temp_schedule2.insert(other_idx, job)\n                makespan2 = compute_makespan(temp_schedule2)\n                second_best_makespan = min(second_best_makespan, makespan2)\n            \n            current_regret = second_best_makespan - makespan\n\n            if makespan < best_makespan or (makespan == best_makespan and current_regret > regret):\n                best_makespan = makespan\n                best_idx = idx\n                regret = current_regret\n\n        state.insert(job, best_idx)\n    \n    #Second stage of the repair: Local search for improvement\n\n    for _ in range(min(DATA.n_jobs, 5)):\n        idx1 = rng.integers(0, len(state.schedule))\n        idx2 = rng.integers(0, len(state.schedule))\n        if idx1 == idx2:\n            continue\n        \n        job1 = state.schedule[idx1]\n        job2 = state.schedule[idx2]\n        \n        state.remove(job1)\n        state.remove(job2)\n        \n        \n        temp_schedule = state.schedule[:]\n        \n        makespan_before = state.objective()\n        \n        \n        best_makespan = float('inf')\n        best_schedule = []\n\n        for i in range(len(temp_schedule) + 1):\n            schedule_with_job1 = temp_schedule[:]\n            schedule_with_job1.insert(i, job1)\n\n            for j in range(len(schedule_with_job1) + 1):\n                schedule_with_job2 = schedule_with_job1[:]\n                schedule_with_job2.insert(j,job2)\n                \n                makespan = compute_makespan(schedule_with_job2)\n                \n                if makespan < best_makespan:\n                    best_makespan = makespan\n                    best_schedule = schedule_with_job2\n                \n\n        if best_makespan < makespan_before:\n            state.schedule = best_schedule\n            \n        else:\n            state.schedule = state.schedule[:] #return to prior state\n            state.insert(job1, idx1)\n            state.insert(job2, idx2)\n            \n\n    return state\n```",
  "function_code": "def llm_repair(state: 'Solution', rng, **kwargs) -> 'Solution':\n    \"\"\"\n    Repair operator for the Permutation Flow Shop Problem (PFSP) using ALNS.\n\n    Args:\n        state (Solution): The current solution.\n        rng: numpy.random.Generator object for random number generation.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Solution: The repaired solution.\n    \"\"\"\n\n    # First, attempt to insert unassigned jobs using a regret-based heuristic.\n    unassigned = state.unassigned[:]\n    rng.shuffle(unassigned)  # Shuffle to introduce randomness\n\n    while unassigned:\n        job = unassigned.pop()\n        best_idx = -1\n        best_makespan = float('inf')\n        regret = -float('inf')\n\n        for idx in range(len(state.schedule) + 1):\n            temp_schedule = state.schedule[:]\n            temp_schedule.insert(idx, job)\n            makespan = compute_makespan(temp_schedule)\n\n            # Calculate regret value\n            second_best_makespan = float('inf')\n            for other_idx in range(len(state.schedule) + 2):\n                if other_idx == idx:\n                    continue\n                temp_schedule2 = state.schedule[:]\n                temp_schedule2.insert(other_idx, job)\n                makespan2 = compute_makespan(temp_schedule2)\n                second_best_makespan = min(second_best_makespan, makespan2)\n            \n            current_regret = second_best_makespan - makespan\n\n            if makespan < best_makespan or (makespan == best_makespan and current_regret > regret):\n                best_makespan = makespan\n                best_idx = idx\n                regret = current_regret\n\n        state.insert(job, best_idx)\n    \n    #Second stage of the repair: Local search for improvement\n\n    for _ in range(min(DATA.n_jobs, 5)):\n        idx1 = rng.integers(0, len(state.schedule))\n        idx2 = rng.integers(0, len(state.schedule))\n        if idx1 == idx2:\n            continue\n        \n        job1 = state.schedule[idx1]\n        job2 = state.schedule[idx2]\n        \n        state.remove(job1)\n        state.remove(job2)\n        \n        \n        temp_schedule = state.schedule[:]\n        \n        makespan_before = state.objective()\n        \n        \n        best_makespan = float('inf')\n        best_schedule = []\n\n        for i in range(len(temp_schedule) + 1):\n            schedule_with_job1 = temp_schedule[:]\n            schedule_with_job1.insert(i, job1)\n\n            for j in range(len(schedule_with_job1) + 1):\n                schedule_with_job2 = schedule_with_job1[:]\n                schedule_with_job2.insert(j,job2)\n                \n                makespan = compute_makespan(schedule_with_job2)\n                \n                if makespan < best_makespan:\n                    best_makespan = makespan\n                    best_schedule = schedule_with_job2\n                \n\n        if best_makespan < makespan_before:\n            state.schedule = best_schedule\n            \n        else:\n            state.schedule = state.schedule[:] #return to prior state\n            state.insert(job1, idx1)\n            state.insert(job2, idx2)\n            \n\n    return state\n",
  "timestamp": "2025-05-22 17:49:33",
  "evaluation": {
    "objective": 